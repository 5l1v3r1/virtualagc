<!DOCTYPE doctype PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <title>The Launch Vehicle Digital Computer</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="author" content="Ron Burkey">
    <link rel="icon" type="image/png" href="favicon.png">
    <meta name="author" content="Ron Burkey">
    <script type="text/javascript" src="Header.js"></script>
  </head>
  <body style="background-image: url(gray3.jpg);">
    <script type="text/javascript">
document.write(headerTemplate.replace("@TITLE@","Launch Vehicle Digital Computer (LVDC)").replace("@SUBTITLE@","Saturn IB and Saturn V Rockets"))
</script>
    <h2>Contents</h2>
    <ul>
      <li><a href="#What_is_the_Launch_Vehicle_Digital_">What is the
          Launch Vehicle Digital Computer (LVDC)?</a></li>
      <li><a href="#Peripheral_Devices">Peripheral Devices</a></li>
      <li><a href="#Interaction_with_the_AGC">Saturn Interaction with
          the AGC</a><br>
      </li>
      <li><a href="#LVDC_Documentation">LVDC Documentation</a></li>
      <li><a href="#LVDC_Software">LVDC Software</a></li>
      <ul>
        <li><a href="#Overall_Structure">Overall Structure</a></li>
        <li><a href="#Preflight_Program">Preflight Program</a></li>
        <li><a href="#Executive_Control_Program">Executive Control
            Program</a></li>
        <li><a href="#Flight_Program_in_General">Flight Program in
            General</a><br>
        </li>
        <li><a href="#Evolution_of_the_Flight_Software">AS-206RAM Flight
            Program Specifically</a></li>
        <li><a href="#PTC_ADAPT_Self-Test_Program">PTC ADAPT Self-Test
            Program</a><br>
        </li>
      </ul>
      <li><a href="#Architecture_of_the_LVDC">Architecture of the LVDC</a></li>
      <ul>
        <li><a href="#References_">References</a></li>
        <li><a href="#General_Characteristics_of_the_Computer_">General
            Characteristics of the Computer</a></li>
        <li><a href="#Layout_of_Memory_Words">Layout of Memory Words</a></li>
        <li><a href="#CPU_Instructions">CPU Instructions</a></li>
        <li><a href="#IO_Ports_For_PIO_Instruction">I/O Ports (for <span
              style="font-family: Courier New,Courier,monospace;">PIO</span>
            Instructions)</a></li>
        <li><a href="#Subroutine_Linkage">Subroutine Linkage</a><br>
        </li>
        <li><a href="#Interrupts">Interrupts</a></li>
        <li><a href="#Telemetry">Telemetry</a></li>
        <li><a href="#Up-data">Up-data</a><br>
        </li>
      </ul>
      <li><a href="#LVDC_Assembly_Language">LVDC Assembly Language</a></li>
      <ul>
        <li><a href="#Basic_Factoids">Basic Factoids</a></li>
        <li><a href="#Preprocessor_Pass">Preprocessor Pass</a></li>
        <li><a href="#Assembly_Pass">Assembly Pass</a></li>
        <li><a href="#ANATOMY">Program Structure</a><br>
        </li>
      </ul>
      <li><a href="#MIT_Instrumentation_Laboratory_vs_IBM">MIT
          Instrumentation Laboratory vs IBM Federal Systems Division</a></li>
      <li><big><a href="#yaLVDC_the_LVDC_CPU_Emulation"><small><small><big><small><big><span
                        style="font-weight: bold;">yaLVDC</span>, the
                      LVDC CPU Emulation</big></small></big></small></small></a></big></li>
      <li><a href="#yaLVDCASM_the_LVDC_Cross-Assembler"><span
            style="font-weight: bold;">yaASM.py</span>, the LVDC
          Cross-Assembler</a></li>
      <li><a href="#Plea_for_Data">Plea for Data</a></li>
      <li><a href="#Homage">Homage</a><br>
      </li>
    </ul>
    <h2><a name="What_is_the_Launch_Vehicle_Digital_"
        id="What_is_the_Launch_Vehicle_Digital_"></a>What is the Launch
      Vehicle Digital Computer (LVDC)?<br>
    </h2>
    <a href="lvdc_upper.jpg"><img alt="" title="Click to enlarge"
        src="lvdc_upper-small.jpg" style="border: 2px solid ; width:
        288px; height: 165px;" width="288" height="165" align="right"></a>The
Launch












































































    Vehicle Digital Computer (LVDC) was a computer that resided in the
    Instrument Unit (IU) that perched above the Saturn IVB that was the
    second stage in a Saturn IB rocket and the third stage in a Saturn V
    rocket.&nbsp; The LVDC was a completely separate computer system
    from the AGC, with a different architecture, different
    instruction-set, and different runtime software.&nbsp; The purpose
    of the LVDC was to precisely control the Saturn from shortly before
    liftoff until the point at which the Saturn was discarded by the
    CSM.&nbsp;<br>
    <br>
    <table summary="" style="text-align: left; width: 60%; margin-left:
      auto; margin-right: auto;" cellspacing="2" cellpadding="2"
      border="1">
      <tbody>
        <tr>
          <td style="vertical-align: top;">
            <div style="text-align: center;"> <span style="font-weight:
                bold; text-decoration: underline;">Factoid</span><br>
            </div>
            People generally think that the guidance computer (AGC) of
            the command module controlled the Saturn rocket, but it
            isn't true.&nbsp; During burns of the S-II and S-IVB rocket
            stages, it <span style="font-style: italic;">was</span>
            possible for the CSM's AGC to control the steering, as a
            backup to the LVDC.&nbsp; That backup capability was never
            used in a mission.&nbsp; This was not possible during burns
            of the first stage (S-IB or&nbsp; S-IC).&nbsp; However, the
            AGC's ability to directly control the Saturn IVB was used
            for other purposes during the mission.&nbsp; <a
              href="#Interaction_with_the_AGC">Also, see below</a>.<br>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <div align="center"><img title="LVDC and friend." alt=""
        src="LVDCandFriend.jpg" width="443" height="377"><br>
      <br>
    </div>
    The LVDC has a less-visible role in people's eyes than the AGC, not
    only because it was used for only a very small portion of the
    individual missions, but also because it had no user interface as
    such.&nbsp; In other words, it was a black box that responded to
    inputs from sensors in the Saturn and to ground telemetry, but there
    was no panel into which astronauts could enter commands or get
    feedback from it.&nbsp; One might well call the LVDC "The Forgotten
    Computer", even more so that the computer of the <a
      href="yaAGS.html">LM's Abort Guidance System</a>.&nbsp;
    Nevertheless, the LVDC's importance is great, because you need to
    actually get the Command Module and Lunar Module into space and
    headed toward the moon if you expect any landings to occur!&nbsp; As
    I understand it, the folks that actually worked on the Saturn
    referred to the Instrument Unit as "The Brain", and that term might
    as well be applied to the LVDC, since it was the brain of The Brain.<br>
    <br>
    <table summary="" style="text-align: left; margin-left: auto;
      margin-right: auto;" cellspacing="2" cellpadding="2" border="0">
      <tbody>
        <tr>
          <td style="vertical-align: top;"><img style="width: 175px;
              height: 900px;" alt="" src="SaturnV-simple.jpg"
              width="175" height="900"><br>
          </td>
          <td>
            <table summary="" style="text-align: left; width: 100%;"
              cellspacing="2" cellpadding="2" border="0">
              <tbody>
                <tr>
                  <td style="vertical-align: middle;"><img style="width:
                      600px; height: 336px;" alt="" src="IU-simple.jpg"
                      width="600" height="336"><br>
                  </td>
                </tr>
                <tr>
                  <td style="vertical-align: top;"><img style="width:
                      600px; height: 255px;" alt=""
                      src="SaturnNavigationScheme-simple.jpg"
                      width="600" height="255"><br>
                  </td>
                </tr>
              </tbody>
            </table>
          </td>
          <td><img style="width: 290px; height: 500px;" alt=""
              src="Saturn1B-simple.jpg" width="290" height="500"><br>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <br>
    The LVDC was developed by IBM Federal Systems Division, rather than
    by the MIT Instrumentation Lab that developed the AGC, so there was
    no overlap in development personnel between the LVDC and AGC
    systems.&nbsp; Furthermore, there was almost no overlap in
    engineering technique, other than that both groups of necessity were
    generally constrained by the technology available at the time.&nbsp;
    For example, both needed to use memory based on ferrite-core
    technology.&nbsp; Moreover, there was no interaction between the
    LVDC and AGC systems.<br>
    <br>
    Actually, there was <i>some</i> interaction between the development
    groups, in the sense that at some point in 1963 or before the idea
    arose that the LVDC might be used in place of the AGC in the CM and
    LM, and that this move might save some time and money.&nbsp; In
    fact, IBM produced a 300+ page report detailing the differences
    between the two systems with the apparent object of arguing this
    point, and the MIT Instrumentation Laboratory's antibodies flooded
    in to destroy the invader with critiques and reports negative of the
    IBM report.&nbsp; In the end, the Instrumentation Lab won this
    particular battle, relegating the LVDC to the relatively small share
    of public attention that it presently enjoys.<br>
    <br>
    <div style="text-align: center;"> <img style="width: 586px; height:
        354px;" alt="" src="SaturnNav-simple.jpg" width="586"
        height="354"><br>
    </div>
    <br>
    <h2><a name="Peripheral_Devices" id="Peripheral_Devices"></a>Peripheral












































































      Devices</h2>
    As with any of the other computer systems we cover here at Virtual
    AGC, the LVDC does not stand alone and do its computing in a
    computing vacuum (so to speak).&nbsp; The subsystems involved are:<br>
    <ul>
      <li>The Launch Vehicle Data Adapter (LVDA) interfaced the LVDC's
        digital signals to the analog world of the Instrument Unit's
        sensors.&nbsp; Actually, the LVDA is so closely coupled to the
        LVDC that it may make more sense to consider them as forming a
        single unit, though packaged separately.<br>
      </li>
      <li>The ST-124-M Inertial Platform Assembly—catchy name!—was an
        inertial measuring unit that supplied the LVDC with information
        about the rocket's orientation and acceleration.&nbsp; It had 3
        integrating accelerometers that measured acceleration with
        respect to the stable (space-fixed as opposed to rocket-fixed)
        platform, as well as angular sensors to measure the orientation
        of the stable platform with respect to the rocket.&nbsp; Like
        the AGC IMU, it was a 3-gimbal system and therefore
        theoretically subject to "gimbal lock", but because the range of
        motion of the rocket during the burn phase, I suppose that
        avoidance of gimbal lock must have been somewhat easier than in
        the CM or LM.<br>
      </li>
      <li>The "Control Computer" or "Flight Control Computer" was an
        analog computer that translated attitude-correction commands,
        angular change, and vehicle lateral acceleration information
        into propulsion-system thruster nozzle and/or engine actuator
        positioning commands.&nbsp; As such, it is of little interest in
        simulation of the LVDC (which is our primary concern at Virtual
        AGC).&nbsp;&nbsp; If the naming of this device seems odd, note
        that it follows the general convention of the word "control"
        being defined to mean the execution of an action that has been
        decided upon elsewhere, and not the act of decision-making.<br>
      </li>
      <li>The Control-EDS Rate Gyros.</li>
      <li>The Control Accelerometers (Saturn IB only).</li>
      <li>The propulsion engine actuators.</li>
      <li>The auxiliary propulsion system.&nbsp; This was a set of 6
        nozzles mounted on the aft end of the S-IVB stage which were
        used to provide attitude control in coasting (non-burn)
        periods.&nbsp; I believe that it may also have provided roll
        control during the S-IVB turn during boost.&nbsp; (The engines
        of the S-IC and S-II stages could provide complete
        pitch/yaw/roll control, but the engine of the S-IVB state could
        only control pitch and yaw, and therefore needed to be
        supplemented to provide control of roll.)&nbsp; The auxiliary
        propulsion system was directly controlled by the Flight Control
        Computer, but the Flight Control Computer was commanded by the
        LVDC.</li>
      <li>Telemetry downlink.</li>
      <li>Command uplink.<br>
      </li>
    </ul>
    At the end of the preceding section was an illustration of a very
    simplified logical view of the interconnection of the LVDC to
    various peripherals.&nbsp; Here is a somewhat more complete
    illustration for the Saturn IB:<br>
    <br>
    <div style="text-align: center;"> <img style="width: 794px; height:
        600px;" alt="" src="LVDC-Peripherals.jpg" width="794"
        height="600"><br>
      <div style="text-align: left;"> and for the Saturn V:<br>
        <div style="text-align: center;"> <img style="width: 800px;
            height: 600px;" alt="" src="LVDC-Peripherals-V.jpg"
            width="800" height="600"><br>
          <div align="left">
            <h2><a name="Interaction_with_the_AGC"
                id="Interaction_with_the_AGC"></a>Saturn Interaction
              with the AGC</h2>
            <p>The LVDC and the AGC did not actually have any direct
              interaction, so we may as well talk about how the AGC
              interacted with the Saturn before immersing ourselves in
              too much detail about the LVDC.<br>
            </p>
            <p><a href="IUFlightControlComputer.jpg"><img alt="Flight
                  Control Computer"
                  src="small-IUFlightControlComputer.jpg" width="201"
                  height="200" border="2" align="right"></a>If you look
              at either of the graphics at the end of the preceding
              section, you'll see the four ways that the Instrumentation
              Unit (IU) in the Saturn IVB and the Spacecraft (i.e, the
              Command Module) — which are separated by a horizontal
              dotted line near the tops of the two graphics —
              interacted:<br>
            </p>
            <ol>
              <li>The Abort Decision signal.</li>
              <li>The Status signal.</li>
              <li>The Mode Command signal.</li>
              <li>The Alternate Steering Commands signals.</li>
            </ol>
            The Saturn was always steered by the so-called Flight
            Control Computer (depicted in the picture at the right), an
            analog computer whose salient characteristic for our
            purposes is that it was <i>not</i> the LVDC.&nbsp; However,
            the flight-control computer did not operate on its own, and
            thus itself needed to be supervised.&nbsp; Normally, that
            supervision was performed, by default, by the LVDC,
            indirectly through the LVDA, the Launch Vehicle Data
            Adapter.<br>
            <p>However, it was also possible for the spacecraft to send
              the flight control computer a signal, the Mode Command,
              which instructed it to accept Alternate Steering Commands
              from the AGC rather than the default steering commands
              from the LVDC/LVDA.&nbsp; Thus, the AGC could steer the
              Saturn IVB (but not some of the other Saturn stages) by
              this mechanism.<br>
            </p>
            <p>Of course, it was also desirable for the spacecraft to be
              able to monitor the activity of the Saturn, even under
              normal conditions when the LVDC was controlling the
              rocket.&nbsp; Since the spacecraft had its own Inertial
              Measurement Unit (IMU), it knew its own orientation and
              acceleration — and hence the Saturn's — at all times, and
              the AGC could integrate these quantities to know the
              velocity and position at all times.&nbsp; Thus it was not
              necessary for the IU to communicate that information to
              the spacecraft in order for the AGC to monitor the
              physical motion of the rocket and to display it for the
              astronauts on the DSKY.<br>
            </p>
            <p>I actually have an interesting graphic of the monitoring
              process to show you.&nbsp; This graphic is not from
              physical system.&nbsp; Rather, Riley Rainey has used the
              "equation defining document" which specified how the
              Instrumentation Unit (IU) was <i>supposed</i> to behave,
              to model the physical behavior of the rocket and the
              spacecraft's IMU, allowing Virtual AGC to monitor the
              launch behavior on a simulated DSKY.&nbsp; Here's a short
              movie he has created of that simulation.&nbsp; It's
              admittedly a little fuzzy, since I blew it up by about 2×,
              but perhaps we'll be able to get a better one sometime in
              the future:</p>
            <div align="center"> <a
                href="RileyRainey/ApolloA%202009-08-05%2022-43-27-68-1200x800-20.mp4"><img
                  alt="Riley Rainey's simulation video" title="Click to
                  play video" src="playRiley.jpg" width="300"
                  height="200" border="2"></a> </div>
            <br>
            Of course, at the left in the video, you can see the
            simulated FDAI and DSKY.&nbsp; At the right, you can see
            telemetry from the AGC.&nbsp; You'll notice that at the
            beginning of the movie, the DSKY's UPLINK indicator is
            on.&nbsp; That's apparently because Riley's simulated DSKY
            (which is his own, and not the simulated DSKY we provide)
            isn't fully functional in the sense of accepting keypad
            input, so Riley is instead feeding the AGC commands via the
            digital uplink.<br>
          </div>
        </div>
      </div>
    </div>
    <h2><a name="LVDC_Documentation" id="LVDC_Documentation"></a>LVDC
      Documentation</h2>
    Sadly, documentation we've been able to collect for the LVDC lags
    far behind that of the AGC or even that of the Abort Guidance
    System, though it's getting better over time.&nbsp; What little
    survives that we have been able to access can be found in our <a
      href="links.html#LVDC">Document Library</a>.<br>
    <br>
    I'm also told that there are a number of published (but not
    necessarily free-of-charge) research papers about the LVDC.&nbsp;
    These may be of assistance if you're an enthusiast, but I cannot
    provide any of them for you, for legal reasons.&nbsp; Specifically,
    you can go to <a href="http://arc.aiaa.org/">the AIAA's website</a>,
    and search for "LVDC".&nbsp; Or as another example, via the IEEE's
    website, you can get an article about the "<a
      href="https://ieeexplore.ieee.org/abstract/document/5388320">Interactive











































































      Saturn Flight Program Simulator</a>", as pointed out to me by one
    of the article's authors.&nbsp; (Thanks, Tom Dillon!)<br>
    <h2><a name="LVDC_Software"></a>LVDC Software</h2>
    <h3><a name="Overall_Structure"></a>Overall Structure</h3>
    <p>Describing the overall structure of the software loaded into the
      LVDC is a bit tricky at the present time.&nbsp; That's because
      documentation is scarce, our cache of original LVDC software is
      sparse, and the original development process seemed quite
      compartmentalized.&nbsp; By the latter, I mean that programmers
      concentrated on the specific areas to which they were assigned,
      and often seem to have had little cognizance of even the most
      basic features of the software when those features happened to be
      outside their narrow specialization.&nbsp; Plus the set of LVDC
      programmers available to me is limited, so I don't have
      representatives of all of those specializations to consult with.<br>
    </p>
    <p>In short, important aspects of my descriptions in these sections
      concerning the gross structure of&nbsp; the software are based on
      my own inferences and on the recollections of developers
      unfamiliar with the details.&nbsp; So my comments about the
      program structure with a large grain of salt.<br>
    </p>
    <p>With that said, let's contrast the overall structure of the LVDC
      code vs the software source code for the Apollo Guidance Computer
      (the programs <a href="Colossus.html">COLOSSUS</a>, <a
        href="Luminary.html">LUMINARY</a>, and so on) and for the <a
        href="yaAGS.html">Abort Guidance System</a>.&nbsp; All of these
      non-LVDC programs were <i>monolithic</i> in nature.&nbsp; What I
      mean by that is that although the AGC and AGS software was
      structured into various semi-independent sections, for which the
      development of each was presided over by specialists in those
      specific areas, the source code for them was nevertheless
      presented to the programmers in a single large chunk — i.e., a
      single, unified program listing.&nbsp; Every AGC or AGS developer
      saw the entire source code, regardless of whether it pertained to
      them or not.&nbsp; The natural result was that it was possible
      (and even likely) for an AGC or AGS developer to have some grasp
      of the large-scale structure of the software, beyond his or her
      own narrow area of specialization.&nbsp; Similarly, every word
      stored in the AGC or AGS core memory came from that source
      code.&nbsp; In that sense, each AGC or AGS program listing was
      entirely self-contained.&nbsp; If you were able to assemble those
      program listings, then you obtained a rope image that could be
      loaded into the computer and run.&nbsp; Conversely, every word in
      core-memory either came directly from the associate program
      listing or from some action taken by the code in that program
      listing.&nbsp; When you look at a program listing for (say)
      LUMINARY, you see the <i>entire</i> contents of the Lunar
      Module's AGC's core memory.<br>
    </p>
    <p>The overall structure of the LVDC software, however, is
      fundamentally different.&nbsp; Simultaneously loaded into the LVDC
      core memory were <i>several</i> different logically-distinct
      "programs", each with <i>different</i> sets of source code,
      assembled <i>separately</i> from each other, and having different
      areas of specialization.&nbsp; Thus assembly of any given one of
      these programs did not produce a full core-rope image: merely a
      partial rope image.&nbsp; A full rope image could be obtained only
      by merging all of the partial core-rope images from the different
      assemblies of the several sets of source code.&nbsp; The separate
      programs I'm aware of are discussed individually in the sections
      that follow, but in brief, they were:<br>
    </p>
    <ul>
      <li>The Preflight Program</li>
      <li>The Executive Control Program</li>
      <li>The Flight Program<br>
      </li>
    </ul>
    <p>A similar situation arises in modern computer systems, where you
      typically have an "operating system" program and "application
      programs" running in the computer at the same time.&nbsp; The
      application programs rely on the operating system for certain
      functionality, but have no understanding of how the operating
      system provides that functionality.&nbsp; All the application
      program needs to know is the exact method for requesting the
      desired function from the operating system.&nbsp; Similarly, the
      operation system stands ready to provide the desired
      functionality, but has no knowledge of the internal workings of
      the application program requesting service.<br>
    </p>
    <p>In the LVDC, the method by which interaction between independent
      but simultaneously-loaded programs worked was for there to be an
      agreed-upon set of specific memory addresses hard coded into the
      programs.&nbsp; For example, one program would know that to obtain
      a certain type of service, it had to call a routine at a certain
      fixed address in memory.&nbsp; Another program would know that it
      had to put code providing certain types of services at certain
      fixed addresses, but have no other knowledge of the program(s)
      utilizing that functionality.<br>
    </p>
    <p>Because of this much higher degree of compartmentalization,
      programmers working on (say) the Flight Program might have no
      cognizance at all of the Preflight Program, the developers of
      which might have no cognizance of the Executive Control Program,
      and so on.&nbsp; And unfortunately, that means that <i>we</i>
      don't, either.<br>
    </p>
    <h3><a name="Preflight_Program"></a>Preflight Program</h3>
    <p>I don't know anything at all about the Preflight Program at
      present.&nbsp; I.e., there is no surviving documentation or source
      code for it as far as I know.&nbsp; I will provide information
      about it if/when it becomes available.<br>
    </p>
    <p>As it relates to the <a href="#Evolution_of_the_Flight_Software">AS-206RAM














        Flight Program</a>, however, I do have a couple of reasons to
      believe that the AS-206RAM Flight Program would have been used in
      conjunction with a Preflight Program:<br>
    </p>
    <ol>
      <li>In the AS-206RAM Flight Program (1967), there are jumps to
        various memory locations in regions of core memory at which
        AS-206RAM itself does not define any code or variables.&nbsp; It
        stands to reason that <i>something</i> is stored there.&nbsp; <a
          href="#Evolution_of_the_Flight_Software">This is discussed in
          more detail below</a>.<br>
      </li>
      <li>One of the original LVDC software developers (thanks, Pat
        Woods!) tells me that he believes that the Flight Program shared
        memory with a Preflight Program that ran before liftoff.</li>
    </ol>
    <h3><a name="Executive_Control_Program"></a>Executive Control
      Program</h3>
    <p>Original LVDC software developer Pat Woods tells me that there
      was no Executive Control Program (ECP) in use until the Apollo 12
      mission.&nbsp; This anecdotal information is backed up by the fact
      that the Saturn Launch Vehicle Astrionics Systems Handbook has 14
      pages of descriptive material about the ECP in its <a
href="http://www.ibiblio.org/apollo/Documents/AstrionicsSystemsHandbook_Nov69.pdf">November













        15 1969 release</a> (see section 11.2.1 in particular), but does
      not even mention the ECP at all in its <a
href="http://www.ibiblio.org/apollo/Documents/MSFC-IV-4-401-1-AstrionicsSystemHandbookSaturnLaunchVehicles.pdf">November













        1 1968 release</a>.<br>
    </p>
    <p>I won't describe the ECP further here, since we have no source
      code for it, but if you are interested you should consult the
      later release of the Astrionics Systems Handbook mentioned above.<br>
    </p>
    <p>It is unfortunately not clear from the description whether the
      ECP constituted a program <i>separate</i> from the Flight Program
      with which it was used — i.e., whether it had a separate set of
      source code that was assembled separately from the Flight Program
      — or whether the two had an integrated code base that was
      assembled as a single operation.<br>
    </p>
    <h3><a name="Flight_Program_in_General"></a>Flight Program in
      General</h3>
    <p>The software was apparently known simply as the Flight Program,
      and didn't have a catchy name such as "Luminary".<br>
    </p>
    <p>You may also see references to the Generalized Flight Program
      (GFP) or generalized Flight Program System, in use from Apollo 12
      onward.&nbsp; You may recall from <a
        href="#Executive_Control_Program">the preceding section</a> that
      the Executive Control Program also came into use from Apollo 12
      onward.&nbsp; My supposition would be that this simply means that<br>
    </p>
    <blockquote>GFP = ECP + FP<br>
    </blockquote>
    Was the software classified?&nbsp; No.&nbsp; Or at least it was not
    classified at the time period from which we begin to have any
    information.&nbsp; Several people associated with the development
    have stated to me that it was classified.&nbsp; But classified
    material must be stamped with one of the designations <tt>CONFIDENTIAL</tt>,
    <tt>SECRET</tt>, or <tt>TOP SECRET</tt>.&nbsp; The available
    software listing is not so stamped, and therefore should not be
    considered classified.&nbsp; Undoubtedly IBM Federal Systems
    Division considered it confidential at the time, under the common
    usage of the word, but that doesn't make it classified.
    <p> </p>
    <h2> </h2>
    <h3><a name="Evolution_of_the_Flight_Software"
        id="Evolution_of_the_Flight_Software"></a>AS-206RAM Flight
      Program<br>
    </h3>
    To a computer programmer, the most important thing about any
    computer program is its source code, and at present a single
    revision of the flight program is available to us.&nbsp; It is an
    engineering revision of the software, from September 1967,
    designated "AS-206RAM LVDC FLIGHT PROGRAM".&nbsp; If you were to
    Google this (<b>don't do it!</b>), you may unnecessarily excite
    yourself by noting that Saturn IB launch vehicle AS-206 was used for
    the Skylab 2 mission (Conrad/Weitz/Kerwin).&nbsp; You may then be
    chagrined to realize that the Skylab 2 mission was in 1973, far past
    the 1967 time frame in which this revision of the program is
    developed.&nbsp; What gives?&nbsp; The answer, is that AS-206 was <i>originally</i>
    intended for an unmanned mission that was canceled after the Apollo
    1 fire.&nbsp; The software we have is not even for that canceled
    early AS-206 mission, but rather for a proposed backup to the
    canceled mission.&nbsp; So whatever software the LVDC had when
    AS-206 eventually launched as Skylab 2, is not <i>this</i>
    software.&nbsp; That doesn't alter the fact that this software is
    ancestral to the versions that followed it ... or at least a very
    close cousin to the ancestor of the versions following it.&nbsp;
    There are some references in the software to AS-205, which is what
    would have been Apollo 2 (the 2nd manned Apollo mission) had the
    tragic Apollo 1 fire not occurred; naturally, Apollo 2 was canceled
    thereafter.&nbsp; The designation AS-205 was <i>later</i> used
    instead for Apollo 7, though considering the time-frames involved,
    it's likely that the reference in the source code is to Apollo 2
    rather than Apollo 7.&nbsp; In other words, the AS-206RAM flight
    program we have had likely been branched off from the LVDC software
    being developed for the never-flown Apollo 2 mission.<br>
    <br>
    From the preceding sections and from the date of the software,
    you'll note that there is likely no Executive Control Program (ECP)
    associated with this software, but that there should be a separate
    Preflight Program (which we know essentially nothing about)
    interacting with it through shared memory.&nbsp; Thus the AS-206RAM
    Flight Program we have does <i>not</i> completely describe the
    contents of LVDC core memory, and thus is not a complete LVDC
    program as it stands.&nbsp; More on this below.<br>
    <br>
    As far as an AS-206RAM mission specifically is concerned, "RAM"
    stands for Restart Alternate Mission.&nbsp; We have the document "<a
      href="Documents/19680007324.pdf">AS-206 S-IVB RESTART ALTERNATE
      MISSION LAUNCH VEHICLE OPERATIONAL FLIGHT TRAJECTORY</a>", which I
    expect would be pretty invaluable in understanding the expected
    operation of the flight program.&nbsp; To quote the document itself,<br>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <blockquote><small>The basic purpose of the Apollo Saturn 206 S-IVB
        Restart Alternate Mission is to place the S-IVB stage into orbit
        and test its restart capability, simulating the AS-501 mission
        profile. In the event S-IVB restart problems occur in the early
        Saturn V flights, this mission will be flown to help correct or
        solve the problems. The primary objective of the SA-206 Launch
        Vehicle is to insert the S-IVB/IU/Payload configuration into a
        near earth 100 nautical mile circular orbit. The payload
        consists of a Spacecraft LM Adapter (SLA) and a 25° Nose Cone
        (NC #2).</small><br>
    </blockquote>
    As usual in these matters, what <i>we</i> have is not the punch
    cards on which the assembly-language source code was originally
    provided to the assembler program, but the "assembly listing" output
    by the assembler.&nbsp; Unfortunately, the status of the assembly
    process for it found 41 warnings and 7 errors — meaning that there
    were problems in the source code and that the assembly process <i>failed</i>.&nbsp;





















































    Thus the program wouldn't actually work as-is anyway, even assuming
    we had an LVDC or a simulation of an LVDC in which to run it.&nbsp;
    That doesn't reduce its instructional value any, though, and it
    doesn't mean that some enterprising individual couldn't fix it up
    now to make it work!<br>
    <br>
    <div align="center"><a href="LVDC-206RAM-teaser.jpg"><img alt=""
          title="Click to enlarge" src="small-LVDC-206RAM-teaser.jpg"
          width="830" height="612" border="2"></a><br>
    </div>
    <br>
    <a name="Skype"></a>When I say "we" have a copy of this assembly
    listing, however, there's an unfortunate proviso.&nbsp; In the U.S.
    there is something called the International Traffic in Arms
    Regulations (ITAR), which prevents export of certain technologies
    from the U.S. except under strict controls.&nbsp; Under my
    non-expert, non-lawyer reading of the ITAR, the LVDC would be such a
    device whose export is prohibited.&nbsp; However, I cannot
    personally figure out whether the LVDC's <i>software</i> would also
    therefore be restricted.&nbsp; If it were restricted, then freely
    providing the software online would be regarded as "exporting" it,
    and would therefore also be prohibited!<br>
    <p>As it happens, the source code from the assembly-listing printout
      has been entirely transcribed into machine readable form.&nbsp;
      That's a lot more convenient to deal with that scanned page
      images, since you can do things like text searches on it, or even
      assemble it using the nifty new LVDC assembler I've written (<a
        href="LVDC.html#yaLVDCASM_the_LVDC_Cross-Assembler">see below</a>).&nbsp;




















      The problem, of course, is that the transcribed source code is
      just as much subject (or hopefully, it will eventually turn out, <i>not</i>
      subject) to ITAR export restrictions as the scanned images are, so
      this LVDC source code is not presently available in our software
      repository.<br>
    </p>
    Yes, I know that all sounds very silly, since there haven't been any
    Saturns since 1973, so nobody is likely to load one of them up with
    a warhead and fire it at anybody ... and never would have anyway,
    due to the tremendous cost involved.&nbsp; And this software
    couldn't target anything on the ground anyway, since its sole
    purpose is to get stuff into orbit.&nbsp; Nevertheless, although the
    law may be an ass (with apologies to Charles Dickens), it is still
    the law.&nbsp; Until this uncertainty about the ITAR status of the
    LVDC software is cleared up, I am forced to regard it as being
    restricted.&nbsp; According to wikipedia, that means that I am
    allowed to give it to only a "<a
      href="https://en.wikipedia.org/wiki/United_States_person">United
      States person</a>".&nbsp; Therefore, if you want the program
    listing, you must obtain it from me personally and provide <a
href="https://www.uscis.gov/us-citizenship/proof-us-citizenship-and-identification-when-applying-a-job">proof</a>
    that you are a United States person as just described. I will retain
    a record of everyone to whom I the program listing.&nbsp; The
    easiest way I've thought of so far of doing this, without forcing
    you to come to me physically, is to have a video call (say, using
    Skype) in which you present a U.S. passport or some other suitable
    picture ID that lists your citizenship, so that I can compare it to
    your actual face. <br>
    <br>
    With all that unpleasantness out of the way, it doesn't seem to me
    that suitably-abridged subsets of the assembly listing would be
    restricted by ITAR, if they do not pertain to guidance, control, or
    other technical aspects of the launch vehicle.&nbsp; <a
href="https://github.com/virtualagc/virtualagc/blob/master/yaASM.py/sample-1967.lvdc">Such




















      an abridged transcription of the source code does indeed appear in
      our software repository</a>. &nbsp; The transcribed code, unlike
    the full program, assembles without error and could actually be run
    on an LVDC or LVDC simulator ... or at least could be run once I
    flesh it out enough to do something useful.&nbsp; That's an evolving
    effort, so feel free to take or leave the abridged LVDC code as you
    see fit.<br>
    <br>
    Since the abridged source code is, as I mentioned, a work in
    progress, I can't really base a discussion on it without the burden
    of having to update the discussion frequently.&nbsp; So for the sake
    of discussion, let's just work with the scanned page image.&nbsp;
    Here are various images of pages of the assembly listing that
    illustrate things like how constants and variables are defined by
    the software, how some standard mathematical functions are encoded,
    and some of the tabular data generated by the assembler:<br>
    <br>
    <p align="center"><a href="LVDC-1967/LVDC-1967-057.jpg"><img
          src="small-LVDC-1967-057.jpg" title="Click to enlarge" alt=""
          width="320" height="240" border="2"></a>&nbsp; <a
        href="LVDC-1967/LVDC-1967-058.jpg"><img
          src="small-LVDC-1967-058.jpg" title="Click to enlarge" alt=""
          width="320" height="240" border="2"></a><br>
    </p>
    <div align="center"><a href="LVDC-1967/LVDC-1967-273.jpg"><img
          alt="" title="Click to enlarge" src="small-LVDC-1967-273.jpg"
          width="320" height="240" border="2"></a>&nbsp; <a
        href="LVDC-1967/LVDC-1967-274.jpg"><img alt="" title="Click to
          enlarge" src="small-LVDC-1967-274.jpg" width="320"
          height="240" border="2"></a>&nbsp; <a
        href="LVDC-1967/LVDC-1967-275.jpg"><img alt="" title="Click to
          enlarge" src="small-LVDC-1967-275.jpg" width="320"
          height="240" border="2"></a>&nbsp; <a
        href="LVDC-1967/LVDC-1967-276.jpg"><img alt="" title="Click to
          enlarge" src="small-LVDC-1967-276.jpg" width="320"
          height="240" border="2"></a><br>
      <br>
      <a href="LVDC-1967/LVDC-1967-278.jpg"><img alt="" title="Click to
          enlarge" src="small-LVDC-1967-278.jpg" width="320"
          height="240" border="2"></a>&nbsp; <a
        href="LVDC-1967/LVDC-1967-279.jpg"><img alt="" title="Click to
          enlarge" src="small-LVDC-1967-279.jpg" width="320"
          height="240" border="2"></a>&nbsp; <a
        href="LVDC-1967/LVDC-1967-280.jpg"><img alt="" title="Click to
          enlarge" src="small-LVDC-1967-280.jpg" width="320"
          height="240" border="2"></a><br>
    </div>
    <div align="center"><br>
      <a href="LVDC-1967/LVDC-1967-310.jpg"><img
          src="small-LVDC-1967-310.jpg" title="Click to enlarge" alt=""
          width="320" height="240" border="2">&nbsp; </a><a
        href="LVDC-1967/LVDC-1967-327.jpg"><img
          src="small-LVDC-1967-327.jpg" title="Click to enlarge" alt=""
          width="320" height="240" border="2"></a><a
        href="LVDC-1967/LVDC-1967-327.jpg">&nbsp; </a><a
        href="LVDC-1967/"><img alt="" src="small-LVDC-1967-more.jpg"
          width="320" height="240" border="2"></a><a href="LVDC-1967/"><br>
      </a></div>
    <br>
    There's some additional <a href="#ANATOMY">description of the
      anatomy of these assembly listings</a> farther down on this page.<br>
    <p>The middle group of pages above shows a few auxiliary subroutines
      for computing the sine, cosine, arctangent, and spare root
      functions, plus a 3×3 matrix-multiply routine.&nbsp; Note that
      these are some of the very algorithms described in section 13 of <a
href="https://www.ibiblio.org/apollo/Documents/satinstunitibm_5.pdf">the
        EDD (LVDC Equation Defining Document)</a>, so the source code
      can actually be compared to the defining documentation if one so
      desired.&nbsp; The two images at the top show an area of the
      program where some constants are defined, while the two at the
      bottom show a portion of the assembly listing's cross-reference
      table.&nbsp; <br>
    </p>
    Additionally, each of the flown Saturns is associated with a report
    known as its "launch vehicle flight evaluation report", and <a
      href="links.html#lvfea">these reports are available for <i>most</i>
      of the missions</a>, though there are a few gaps.&nbsp; Chapter 2
    of each of the reports divides the mission into a set of "time
    bases", called T<sub>0</sub>, T<sub>1</sub>, ..., T<sub>5</sub>, T<sub>5A</sub>,
    T<sub>6</sub>, ..., T<sub>9</sub>, and each time base itself
    consists of a series of events that are supposed to occur at
    different times.&nbsp; For example, time base T<sub>0</sub> is
    always the "Guidance Reference Release", and comprises events such
    as "S-IC Engine Start Sequence Command", "S-IC Engine No. 1 Start",
    and so on.&nbsp; But in general, not all missions use all of the
    time bases, and the time bases aren't necessarily used for the same
    thing on different missions.<sub><br>
      <br>
    </sub> As noted above, we're pretty sure that for Apollo 12 and
    beyond, a single Generalized Flight Program (GFP) was used, but we
    have no good information about preceding missions.&nbsp; By
    examining the time bases on a mission-by-mission basis, it's
    possible to roughly deduce which missions <i>may</i> have flown
    with the same LVDC software (though with differing preloaded
    constants) vs the missions which must necessarily have used a
    different revision of the LVDC software.&nbsp; Thanks to Nik Beug
    for pointing this out.&nbsp; While such an analysis has not been
    done comprehensively, a rough analysis of the gross similarities in
    the time bases might indicate the need for at least the following
    additional LVDC software revisions other than the GFP:<br>
    <ul>
      <li>... prior? ...<br>
      </li>
      <li>AS-501 (Apollo 4)<br>
      </li>
      <li>AS-502 (Apollo 6)<br>
      </li>
      <li>AS-503 (Apollo 8)<br>
      </li>
      <li>AS-504 (Apollo 9)<br>
      </li>
      <li>AS-505 and 506 (Apollo 10-11)<br>
      </li>
    </ul>
    <p>Regarding preloaded constants for LVDC memory, all missions (I
      think!) were associated with a report called the "launch vehicle
      operational flight trajectory", and these documents (among other
      things) listed the LVDC preload settings.&nbsp; Unfortunately,
      most of these reports are presently unavailable, though <a
        href="links.html#Miscellaneous_Mission_Documents">we do have a
        few of them</a>.&nbsp; For example, the AS-202 report says that
      "LVDC symbol" T<sub>1i</sub>, the time-to-go for first IGM stage,
      is preloaded with 299.25 sec, while Vex<sub>1</sub>, the J2
      exhaust velocity for first IGM stage, is loaded with 4165.45
      m/sec, and so on.<br>
    </p>
    <p>Finally, I claimed earlier that the AS-206RAM Flight Program is
      not, of itself, a complete program.&nbsp; In that assessment, I'm
      not referring to the fact that when you try to assemble it you
      find that there are a few missing symbols, associated with
      variables that haven't been allocated.&nbsp; <i>That</i> problem
      is simply due to the fact that the listing we have is an
      engineering version of the code that had never been debugged to
      the point of being released.&nbsp; It's quite easy, I think, to
      fix up the assembly-time errors and warnings in the AS-206RAM so
      that it assembles error-free, and is entirely self-contained in
      that sense.&nbsp; But it is still not complete in the larger sense
      I mean.<br>
    </p>
    <p>Rather, when I say that AS-206RAM is incomplete, I mean that it
      references code at specific hard-coded addresses which are not
      defined by the AS-206RAM program.&nbsp; Indeed, there are large
      areas of core memory left undefined by the program.&nbsp; Even the
      location in memory at which the power-up entry point should be
      stored is left undefined.&nbsp; But for example, consider the
      concrete example of the code necessary for processing commands
      uploaded to the LVDC from mission control, as described in <a
        href="#Up-data">the Up-data section of this web-page</a>.&nbsp;
      When such a command is uploaded to the LVDC, an interrupt
      occurs.&nbsp; The software then looks in an interrupt-vector
      table, which appears on p. 207 of the program listing, and looks
      like the following:<br>
    </p>
    <p align="center"><img src="iptable206RAM.jpg" alt="" width="957"
        height="242"><br>
    </p>
    What the interrupt-vector table contains is <tt>HOP</tt>
    instructions that cause control to be transferred to the routines
    for servicing the various interrupt types ... in this case, an
    uploaded-command interrupt, the instruction that will be executed is
    <tt>HOP HCCMDC</tt>.&nbsp; The symbol <tt>HCCMDC</tt> refers to a
    variable that holds a HOP constant defining the location in memory
    and the data-memory setup for the appropriate interrupt-service
    routine, as defined on p. 20 of the listing:<br>
    <br>
    <div align="center"><img src="hccmdc206RAM.jpg" alt="" width="885"
        height="93"><br>
      <div align="left"><br>
        In other words, the interrupt-service routine for a
        command-upload is in memory module 4, sector 17, and its entry
        point is syllable 1 of location 267.&nbsp; Similarly, the
        data-memory environment associated with that interrupt-service
        routine is module 4, sector 17.<br>
        <br>
        And yet ... the source code contains no code in module 4, sector
        17.&nbsp; Indeed, module 4 sector 17 does not even appear at all
        in the octal listing of the assembled AS-206RAM code.&nbsp; Some
        initialization routines do actually <i>dynamically</i>
        initialize a handful of constants in that sector, but they
        certainly do not seem to put any code at those locations.&nbsp;
        <br>
        <br>
        Thus if a command-upload interrupt were to occur, the result
        would be that the software jumped into the middle of a no-man's
        land of uninitialized memory.&nbsp; And it's not just the
        command-upload interrupt, you can see from the image above that
        other no-man's-land jumps could occur as well:&nbsp; to the
        self-test program, to the hardware evaluation program, or upon
        telemetry-station acquisition.<br>
        <br>
        My inference from all that is that there is a separately
        assembled program which provides the code in those locations,
        and <a href="#Preflight_Program">as discussed earlier</a>, the
        best candidate for that at the moment is the Preflight Program
        ... for which we have no source code and no description
        whatsoever.<br>
        <br>
        That's not to say that AS-206RAM cannot be run.&nbsp; One
        workaround for this specific problem is to simply modify the
        interrupt-vector table to contain a <tt>HOP HCIRTN</tt>
        instruction in place of the <tt>HOP HCCMDC</tt> instruction it
        contains now.&nbsp; Another workaround would be to simply
        disable the command-upload interrupt.&nbsp; But alas, that's
        just one example of the potential range of problems the missing
        Preflight Program might cause.&nbsp; Until a complete survey of
        all jumps into no-man's land is made, it's impossible to know
        yet whether all of them can be worked around so easily.<br>
        <h3><a name="PTC_ADAPT_Self-Test_Program"></a>PTC ADAPT
          Self-Test Program</h3>
        <p><i>(This section is under construction.&nbsp; Its contents
            may not yet be reliable.)</i><br>
        </p>
        <p>This section concerns the "PTC ADAPT Self-Test
          Program".&nbsp; Strictly speaking, this program is not LVDC
          software, and it is certainly not LVDC <i>flight</i>
          software.&nbsp; But it fills in an important gaps in our
          understanding of the LVDC and it is technically so close to
          being "LVDC software" that it's really a matter of opinion as
          to whether you want to call it that or not.&nbsp; (Hint:&nbsp;
          I <i>do</i> want to call it that.)&nbsp; Let's begin the
          explanation with a little terminology:<br>
        </p>
        <ul>
          <li>The PTC ("Programmable Test Controller") was ground-based
            IBM Federal Systems Division equipment for evaluating the
            LVDC and/or LVDA, using either the ADAPT or the ASTEC
            laboratory test equipment. <br>
          </li>
          <li>The ADAPT ("Aerospace Data Adapter/Processor Tester"), in
            turn, was equipment to evaluate the LVDA.</li>
          <li>The ASTEC ("Aerospace System Test And Evaluation Console")
            was equipment to evaluate the LVDC and LVDA separately or to
            evaluate the LVDC/LVDA integration.</li>
        </ul>
        <p><a href="Documents/19730064346_1973064346.pdf">The PTC is
            documented here</a>, while <a
            href="Documents/19730064186_1973064186.pdf">the ADAPT and
            ASTEC are documented here</a>.&nbsp; The former document
          (Chapter 7) helpfully includes a printout of the assembly
          listing of a large chunk of software that it calls the "PTC
          ADAPT Self-Test Program".<br>
        </p>
        <p>But it's not necessary to go into great detail about most of
          that at the moment.&nbsp; For our immediate purposes, the only
          important things to note about the PTC and ADAPT are:<br>
        </p>
        <ol>
          <li>The PTC contains a CPU ... <i>which is a modified LVDC</i>.</li>
          <li>The PTC's CPU runs software — in this case, the ADAPT
            self-test program — which is essentially LVDC software, able
            to be assembled by the LVDC assembler, and potentially to be
            run in an LVDC simulator.</li>
        </ol>
        <p>In particular, we would expect the PTC ADAPT Self-Test
          program to match LVDC Flight Program syntax.&nbsp; Indeed, its
          assembly listing has clearly been produced by the LVDC
          assembler program, although there are a few differences in the
          way some of the output is formatted.&nbsp; In terms of how the
          PTC's CPU has been "modified" relative to the LVDC, here's a
          list of some of the differences visible at the software level,
          though admittedly it may not be too meaningful to you until
          you study more about how the LVDC works (and particularly its
          instruction set) later on:<br>
        </p>
        <ul>
          <li>LVDC CPU instructions eliminated in the PTC CPU:&nbsp; <tt>MPY</tt>
            and <tt>MPH</tt> (both of which are multiplication
            instructions), <tt>DIV</tt> (divide), and <tt>EXM</tt>
            ("execute modified").</li>
          <li> Instructions added to the PTC but not present in
            LVDC:&nbsp; <tt>PRS</tt> (printer operation) and <tt>CIO</tt>
            (CPU i/o control).<br>
          </li>
        </ul>
        <p>As self-test software, significant chunks of the program are
          devoted to testing the CPU instructions itself ... i.e., deep,
          system-level self-test code which is not present in the LVDC
          Flight Program.&nbsp; This is obviously a very significant
          feature in terms of helping to test any eventual LVDC CPU
          emulator we may be able to come up with.&nbsp; Unfortunately,
          experience with the AGC suggests that the most-interesting
          CPU-instruction testing we could have would be extensive
          checks of the <tt>DIV</tt> instruction, and probably of the
          behaviorally very-complex <tt>EXM</tt> instruction.&nbsp;
          These are the very instructions which the PTC omits from its
          repertoire, and naturally it cannot test them.&nbsp; Oh, well!<br>
        </p>
        <p>The PTC ADAPT Self-Test Program is also quite significant in
          terms of size, since it is nearly 60% the size of the
          AS206-RAM Flight Program covered in the preceding section
          above.&nbsp; On the other hand, much more of the program is
          explicitly devoted to routine bookkeeping, which in the LVDC
          program would instead be implicitly handled by the assembler,
          which means that not all of the bulk is related to complexity.
          But most significantly, there's no question of the PTC ADAPT
          Self-Test Program's "export" being restricted by ITAR:&nbsp;
          It isn't!&nbsp; So it can be freely provided to you, and you
          need not (please don't!) apply personally to me to get access
          to it.&nbsp; An additional bonus is that while the AS206-RAM
          assembly listing we have is simply a snapshot of work of
          ancient work in progress, which cannot even be assembled
          error-free without a bit of massaging, the PTC ADAPT Self-Test
          Program is a mature, debugged, working program.<br>
        </p>
        <p>As far as the versioning of the software, there is nothing
          embedded within the assembly listing itself which dates
          it.&nbsp; However, given that it is printed in the PTC
          document mentioned above, which is dated 5 MARCH 1965, I think
          we can tentatively suppose that the software too is from early
          1965.&nbsp; (Whereas the AS206-RAM program is from late 1967.)<br>
        </p>
        <p>Beyond that, there's also the academic question of the
          versioning of the LVDC assembler used.&nbsp; Both the feature
          set and the format of the output is more primitive in the PTC
          assembly than in the AS206-RAM assembly.&nbsp; For all these
          reasons, it's fair to infer that an earlier version of the
          assembler was used for the PTC assembly, in which these
          more-advanced convenience features did not yet exist.<br>
        </p>
        <p>The PTC ADAPT Self-Test Program will be transcribed into
          source-code files Real Soon Now, so that it can be assembled
          by the yaASM.py assembler.&nbsp; That has not yet occurred,
          but you can observe its progress online if you like:<br>
        </p>
        <p align="center"><a
href="https://github.com/virtualagc/virtualagc/tree/master/PTC-ADAPT-Self-Test-Program">Folder








            in our GitHub repository for PTC ADAPT Self-Test Program
            source-code files</a></p>
        <p>For now, though, only the <i>scanned</i> assembly listing is
          available.&nbsp; To make it a little more convenient to work
          with, I've extracted the listing from the original scanned PTC
          document linked above, so that it can be viewed as a set of
          image files, one per scanned page of the listing:<br>
        </p>
        <div align="center">
          <blockquote>
            <p><a
                href="ScansForConversion/PTC%20ADAPT%20Self-Test%20Program.zip">Zipfile








                of scanned page images for the PTC ADAPT Self-Test
                Program</a></p>
          </blockquote>
        </div>
        <p>Here's a quick index to the zipfile:<br>
        </p>
        <ul>
          <li>The source-code listing:&nbsp; pp. 1-171</li>
          <li>The symbol table: pp. 172-220</li>
          <li>The assembled octal listing:&nbsp; pp. 221-284</li>
        </ul>
        <p>These images correspond to the original PTC document's pages
          434-717.&nbsp;&nbsp; In general, the entire Chapter 7
          ("Calibration") of that document is relevant, as it contains
          detailed flowcharts for the program, in addition to operating
          instructions.&nbsp; Chapter 2 ("Theory of Operation") contains
          detailed information about the PTC CPU and its peripheral
          devices.<br>
        </p>
      </div>
    </div>
    <h2><a name="Architecture_of_the_LVDC" id="Architecture_of_the_LVDC"></a>Architecture
of












































































      the LVDC</h2>
    <h3><a name="References_" id="References_"></a>References<br>
    </h3>
    Unlike the AGC or AGS/AEA, there is no single document or couple of
    documents we've discovered so far that pull together the complete
    details of how the LVDC operates.&nbsp; You can look at the full set
    of <a href="links.html#LVDC">LVDC documents we've collected in our
      document library</a>.&nbsp; But the specific documents helpful for
    piecing together this section, none of which were originally
    intended as documentation for developers, are the following:<br>
    <ol>
      <li>1 October 1963:&nbsp; <a
          href="Documents/IBMStudyReport-63-928-130-Volume2.pdf"> <span
            style="font-style: italic;">Apollo Study Report, Volume II</span></a>,
        which was part of IBM's feasibility study for using the LVDC in
        place of the AGC in the LM and CM.</li>
      <li>31 October 1963:&nbsp; IBM's <a
href="Documents/IBM-63-928-137-SaturnVGuidanceComputer-SemiannualProgressReport.pdf"><span
            style="font-style: italic;">Saturn V Guidance Computer,
            Semiannual Progress Report</span></a>.</li>
      <li>30 November 1964:&nbsp; <a
href="Documents/LaboratoryMaintenanceInstructionsForLVDC-Volume1-GeneralDescriptionAndTheory.pdf"><span
            style="font-style: italic;">Laboratory Maintenance
            Instructions: Saturn V Launch Vehicle Digital Computer,
            Simplex Models, Volume I: General Description and Theory</span></a>.&nbsp;
This












































































        is IBM's documentation for the LVDC "breadboard model II"
        system.&nbsp; (I'm not presently aware of any existing
        documentation of the production "TMR" LVDC.)&nbsp; <br>
      </li>
      <li>1 February 1966:&nbsp; "<a
href="Documents/TM-X-53384-TheAstrionicsSystemOfSaturnLaunchVehicles-Decher.pdf">The
Astrionics












































































          System of Saturn Launch Vehicles</a>" by Rudolf Decher.</li>
      <li>1 November 1968:&nbsp; <a style="font-style: italic;"
href="Documents/MSFC-IV-4-401-1-AstrionicsSystemHandbookSaturnLaunchVehicles.pdf">Astrionic












































































          System Handbook, Saturn Launch Vehicles</a>, chapters 11 and
        15.</li>
      <li>1 November 1968:&nbsp; <a style="font-style: italic;"
          href="Documents/MSFC-MAN-503-SaturnFlightManual-SA503.pdf">
          Saturn Flight Manual, SA-503</a>, chapter VII, particularly
        data on interrupts and i/o.</li>
      <li>30 September 1972:&nbsp; <a
          href="Documents/MSFC-MAN-206-SkylabSaturnIBFlightManual.pdf"><span
            style="font-style: italic;">Skylab Saturn IB Flight Manual</span></a>,
        chapter VI, again for data on interrupts and i/o.</li>
    </ol>
    Among these, it would be fair to state that reference #3 was used
    primarily (the instruction set is covered in table 2-8 on pp. 2-16
    through 2-20), and the others were used to cross-check or to provide
    guidance or information missing from reference #3.&nbsp; (In
    retrospect, however, I would recommend reference #4 as a better
    starting point to those readers who don't find <i>my</i> musings
    amusing, though it does not cover the instruction set.)&nbsp; Where
    there were discrepancies between earlier documents and later
    documents, the later documents were treated as definitive.
    <h3><a name="General_Characteristics_of_the_Computer_"
        id="General_Characteristics_of_the_Computer_"></a>General
      Characteristics of the Computer<br>
    </h3>
    <div style="text-align: center;"> <img style="width: 1371px;
        height: 771px;" alt="" src="LVDC-block-diagram.jpg" width="1371"
        height="771"><br>
      <br>
      <div style="text-align: left;"> The illustration above shows a
        simplified block diagram of the LVDC.&nbsp; The device itself
        was designed and manufactured by IBM Federal Systems
        Division.&nbsp; Mechanically, the LVDC had dimensions of about
        29.5"×12.5"×10.5", and weighed about 72.5 pounds.&nbsp; A number
        of different power supplies were needed:&nbsp; +6V, -3V, +12V,
        and +20V, at roughly 150W.&nbsp;<br>
        <br>
        However, the LVDC and the Launch Vehicle Data Adapter (LVDA)
        really operated as a pair, and neither is of use without the
        other, so in considering the mechanical and electrical
        characteristics of the LVDC one really needs to include those of
        those of the LVDA into their thinking.&nbsp; The LVDA had
        dimensions of about TBD"×TBD"×TBD", and weighed about 214
        pounds.&nbsp; Its electrical budget was about 320W and it
        accepted +28V power.&nbsp; The purpose of the LVDA was basically
        to intermediate between the LVDC and the remainder of the
        rocket.<br>
        <br>
        In computer terms, LVDC had the following characteristics:<br>
        <ul>
          <li>The computer was triply redundant, with 3 identical
            circuits conforming to the block diagram shown above.&nbsp;
            There was a "voting" circuit not shown, and any two of the 3
            sub-systems could outvote the other on every output control
            signal.<br>
          </li>
          <li>Memory was ferrite core and was entirely RAM.&nbsp; In
            other words, there was no ROM memory as there was in the
            AGC.&nbsp; This meant that the flight program could
            theoretically be changed much closer to flight time than
            could the program of the AGC, but it also meant that the
            program contained within the computer could be destroyed
            much more easily than with the AGC.&nbsp; (But remember, the
            operating life of the LVDC was very short compared to that
            of the AGC.)&nbsp; Actually, reading RAM based on ferrite
            cores is inherently destructive, so every read must be
            accompanied by a write-back operation to restore the
            contents of memory.<br>
          </li>
          <li>Memory words were 28 bits, with 2 of those bits being for
            parity, and thus the data portion of memory words was only
            26 bits.&nbsp; Memory was accessed serially, at a 512K
            bits/second rate, though this fact is not relevant as far as
            software coding is concerned.</li>
          <li>Each memory word was logically subdivided into two 14-bit
            "syllables" (13 data bits + 1 parity bit), and computer
            instructions were encoded in 13 bits.&nbsp; Therefore, each
            memory word could hold two computer instructions, one in
            each syllable.&nbsp; Data, on the other hand, required a
            complete word.<br>
          </li>
          <li>The total amount of memory varied from mission to mission,
            I believe.&nbsp; The LVDC could be populated with up to 8
            modules of memory, with each module comprising 16 "sectors"
            of 256 words each (4096 words), for a maximum of 32768
            words.&nbsp; One word in each block wasn't memory as such
            but was a mirror of the CPU's Product-Quotient Register (see
            below), so the usable memory in each block was really only
            4095 words.&nbsp;<br>
          </li>
          <li>Memory could be operated in two different modes, under
            program control, called "simplex" and "duplex".&nbsp; In
            "duplex" mode, the memory was divided into two banks, each
            of which was an identical mirror of the other in order to
            improve reliability, whereas in "simplex" mode the memory
            wasn't redundant in this way (though it was still triply
            redundant as mentioned above) but the number of memory words
            was double.&nbsp; In duplex mode, the odd-numbered modules
            mirrored the even-numbered modules, so that one would
            typically used only modules 0, 2, 4, and 6 in duplex
            mode.&nbsp; For the AS-206RAM LVDC Flight Program, a simplex
            model was required.<br>
          </li>
          <li>The basic CPU clock was 2048 KHz, but computer
            instructions were executed in a "computer cycle" time which
            was 82.03125μs.&nbsp; The latter may seem like an unusual
            number, but where it comes from is that each instruction
            required reading/writing 3 syllables (1 holding the
            instruction and 2 holding the data) of 14 bits each, with
            each bit requiring 4 clocks to process. 3×14×4=168, so the
            computer cycle was 168/(2.048MHz)=82.03125μs.&nbsp; Although
            most instructions took a single computer cycle, some
            instructions (particularly multiplication and division) took
            longer.&nbsp; The longest instruction, <span
              style="font-family: Courier New,Courier,monospace;">MPH</span>,
            took 5 cycles.&nbsp; The <span style="font-family: Courier
              New,Courier,monospace;">MPY</span> and <span
              style="font-family: Courier New,Courier,monospace;">DIV</span>
            instructions (see below) theoretically took only a single
            cycle, but could only begin their operations in that amount
            of time, and the results weren't accessible until later (4
            cycles total for <span style="font-family: Courier
              New,Courier,monospace;">MPY</span> and 8 cycles total for
            <span style="font-family: Courier New,Courier,monospace;">DIV</span>).<br>
          </li>
          <li>Arithmetic was 2's complement, integer only.</li>
          <li>There were two arithmetic units, one of which could
            perform addition, subtractions, and logical operations,
            whilst the other could perform multiplication and
            division.&nbsp; The two units could be operated
            independently, which is significant because multiplications
            required 4 computer cycles and divisions required 8 computer
            cycles, and instruction execution could continue while the
            multiplication or division proceeded.&nbsp; In other words,
            one could begin a multiplication or division, proceed to
            execute some unrelated instructions, and then later fetch
            the results of completed multiplication or division.<br>
          </li>
        </ul>
      </div>
    </div>
    The CPU had the following additional registers not addressable as
    normal memory:<br>
    <ul>
      <li>The Accumulator Register.</li>
      <li>The Product-Quotient Register (or just P-Q Register) can be
        accessed at address 0775 (octal) regardless of which memory
        modules and sectors were currently selected.&nbsp; (This happens
        to be an address in the "residual sector", as described below,
        so it represents a single address in each memory module rather
        than an address within each memory sector.)&nbsp; However, it is
        used by the <span style="font-family: Courier
          New,Courier,monospace;">MPY</span> and <span
          style="font-family: Courier New,Courier,monospace;">DIV</span>
        instructions (see below) and therefore cannot be treated as an
        ordinary memory location.</li>
      <li>The HOP Register, discussed further below.</li>
      <li>... and various hidden registers not directly relevant to
        software:&nbsp; the Transfer Register, the Address Register, the
        Data Module Register, the Data Sector Register, the Instruction
        Sector Register, the Operation Code Register, and the Memory
        Buffer Registers.</li>
    </ul>
    There are some memory words in the "residual sector" (see below)
    that are real memory (unlike 0775), but nevertheless have special
    purposes and so should be avoided for general usage:<br>
    <ul>
      <li>0400 stores a HOP Register code (see below) for vectoring to
        interrupts.<br>
      </li>
      <li>0600, 0640, 0700, 0740 are used for the <span
          style="font-family: Courier New,Courier,monospace;">EXM</span>
        instruction (see below).</li>
      <li>0776, 0777 are used for the "HOP save" feature (see below).</li>
    </ul>
    Finally, address 000—I believe, in module 0 sector 0 but am not
    sure—stores a HOP Register code loaded at reset.<br>
    <h3><a name="Layout_of_Memory_Words" id="Layout_of_Memory_Words"></a>Layout
of












































































      Memory Words</h3>
    <br>
    <div style="text-align: center;"> <img style="width: 896px; height:
        166px;" alt="" src="LVDC-BitPositions.jpg" width="896"
        height="166"><br>
    </div>
    <br>
    The illustration above depicts the data organization within a memory
    word.&nbsp;&nbsp; For numeric data, there is a sign bit (designated
    "S" in the illustration), with the bit labeled "1" being the
    most-significant bit and the bit labeled "25" being the
    least-significant bit.&nbsp; For non-numeric data, the bits were
    designated instead as "1" through "26", with no overlap between the
    designation of the bits for numeric data.&nbsp; A very curious
    system indeed, in modern thinking!<br>
    <br>
    The situation is even curiouser, to paraphrase Alice, when
    considering instructions stored in the syllables in place of numeric
    data.&nbsp; In those cases the bits are interpreted as in the
    following illustration:<br>
    <div style="text-align: center;"> <img style="width: 899px; height:
        169px;" alt="" src="LVDC-InstructionPositions.jpg" width="899"
        height="169"><br>
    </div>
    <br>
    The instruction in Syllable 0 is processed first, and the
    instruction in Syllable 1 is processed second.&nbsp; In most cases,
    the bits labeled OP1-OP4 contain an instruction code and the bits
    A1-A9 contain an address in the range 0-511 on which the instruction
    operates.&nbsp; There are, however, a few instructions in which A9
    and/or A8 also form a part of the instruction code, in which case
    the addressable range is smaller.&nbsp; Note that bits A1-A9 are
    neither in consecutive order within the memory word, nor are they in
    an order which would be consistent with the ordering of bits in data
    words.<br>
    <br>
    These oddities in bit-ordering are due to the fact that memory was
    read serially into the CPU, so the ordering of the bits is optimized
    to mimic the order in which the CPU needed to use them.<br>
    <br>
    For the purpose of executing instructions, memory is considered as
    being divided into "sectors" of 256 words each.&nbsp; Address bits
    A1-A8 select an offset into a sector, while A9 (known as the
    "residual bit") selects which sector is being addressed.&nbsp; When
    A9 is 0, the currently-selected sector is being addressed, while
    when A9 is 1 a special sector called the "residual sector" is being
    addressed.&nbsp; <span style="font-style: italic;">The "residual
      sector" is always sector 017 (octal) in the current memory module</span>.&nbsp;
Incidentally,












































































    the "residual sector" can only be used for addressing memory, and
    there's no way to access instructions in it unless it happens to be
    the currently-selected instruction sector as explained in the
    paragraph that follows.&nbsp; In essence, the "residual sector" is
    good for storing global variables whilst the currently-selected data
    sector is good for storing local variables.<br>
    <br>
    Memory-sector selection and the "residual sector" become clearer
    when contemplating the HOP Register mentioned earlier:<br>
    <br>
    <div style="text-align: center;"> <img style="width: 868px; height:
        293px;" alt="" src="LVDC-HopRegister.jpg" width="868"
        height="293"><br>
    </div>
    <br>
    The meanings of these fields may already be clear to you, but just
    in case they are not:<br>
    <ul>
      <li>Bits IM1-IM3 (not contiguous) select the memory module from
        which instructions are fetched.&nbsp; (Recall that there are up
        to 8 memory modules installed in the LVDC.)</li>
      <li>Bit DUPIN selects whether the portion of memory from which
        instructions are fetched is accessed in duplex mode or in
        simplex mode.&nbsp; (Recall that in duplex mode there is only
        half the addressable memory as in simplex mode, because the
        memory is dual-redundant and half of the memory mirrors the
        other half.)</li>
      <li>Bits IS1-IS4 select the 256-word sector within the selected
        memory module from which instructions are fetched.</li>
      <li>Bits A1-A8 (the Instruction Counter) point to the next
        instruction word to be fetched from the selected sector in the
        selected block.</li>
      <li>Bit SYL indicates the next instruction syllable in the next
        instruction word.</li>
      <li>And similarly, bits DM1-DM3, bit DUPDN, and bits DS1-DS4 serve
        analogous purposes except for data words rather than instruction
        words.</li>
    </ul>
    Upon reset, the CPU loads the HOP Register with the value stored at
    address 000 (presumably in memory module 0 sector 0), and this
    determines where program execution starts.<br>
    <br>
    Below are some photos sent to us by Dmitris Vitoris of an LVDC "page
    assembly", which I suppose (but am not sure) is a memory
    module.&nbsp; (I'm not really sure which is the best photo, so I've
    just included them all.)<br>
    <br>
    <table summary="" style="text-align: left; width: 100%;"
      cellspacing="2" cellpadding="2" border="0">
      <tbody>
        <tr align="center">
          <td style="vertical-align: top;"><a href="P9280522.JPG"><img
                alt="LVDC page assembly, end view" title="Click to
                enlarge" src="small-P9280522.JPG" style="border: 2px
                solid ; width: 640px; height: 100px;"></a><br>
          </td>
        </tr>
        <tr align="center">
          <td style="vertical-align: top;">
            <table summary="" style="text-align: left; width: 100%;"
              cellspacing="2" cellpadding="2" border="0">
              <tbody>
                <tr>
                  <td style="vertical-align: top; text-align: center;"><a
                      href="P9280508.JPG"><img alt="LVDC page assembly"
                        title="Click to enlarge"
                        src="small-P9280508.JPG" style="border: 2px
                        solid ; width: 213px; height: 160px;"></a><br>
                  </td>
                  <td style="vertical-align: top; text-align: center;"><a
                      href="P9280512.JPG"><img alt="LVDC page assembly,
                        top view" title="Click to enlarge"
                        src="small-P9280512.JPG" style="border: 2px
                        solid ; width: 213px; height: 160px;"></a><br>
                  </td>
                  <td style="vertical-align: top; text-align: center;"><a
                      href="P9280515.JPG"><img alt="LVDC page assembly,
                        top view" title="Click to enlarge"
                        src="small-P9280515.JPG" style="border: 2px
                        solid ; width: 213px; height: 160px;"></a><br>
                  </td>
                  <td style="vertical-align: top; text-align: center;"><a
                      href="P9280516.JPG"><img alt="LVDC page assembly,
                        top view" title="Click to enlarge"
                        src="small-P9280516.JPG" style="border: 2px
                        solid ; width: 213px; height: 160px;"></a><br>
                  </td>
                </tr>
              </tbody>
            </table>
            <br>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <h3><a name="CPU_Instructions" id="CPU_Instructions"></a>CPU
      Instructions</h3>
    <table summary="" style="text-align: left; width: 100%;"
      cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <th><br>
            <br>
            Mnemonic<br>
          </th>
          <th><br>
            A<br>
            8<br>
          </th>
          <th><br>
            A<br>
            9<br>
          </th>
          <th>O<br>
            P<br>
            4<br>
          </th>
          <th>O<br>
            P<br>
            3<br>
          </th>
          <th>O<br>
            P<br>
            2<br>
          </th>
          <th>O<br>
            P<br>
            1<br>
          </th>
          <th style="vertical-align: top; text-align: center;"> Timing<br>
            (computer<br>
            cycles)<br>
          </th>
          <th><br>
            <br>
            Description of the instruction<br>
          </th>
        </tr>
        <tr>
          <td style="font-family: Courier New,Courier,monospace;"> HOP<br>
          </td>
          <td>X<br>
          </td>
          <td>X<br>
          </td>
          <td>0<br>
          </td>
          <td>0<br>
          </td>
          <td>0<br>
          </td>
          <td>0<br>
          </td>
          <td style="text-align: center;">1<br>
          </td>
          <td>This instruction combines an unconditional jump
            instruction with various other configuration options, such
            as memory-sector selection.&nbsp; The way it works is that
            the address A1-A9 points to a memory word that contains a
            "HOP constant", and the <span style="font-family: Courier
              New,Courier,monospace;">HOP</span> instruction transfers
            that HOP constant into the HOP register.&nbsp; Recall that
            A1-A8 select the offset within a 256-word sector, and A9 is
            the "residual bit" that selects between the current sector
            and the "residual sector".&nbsp; There is no provision for a
            partial HOP constant, and the full HOP constant needs to be
            given every time a <span style="font-family: Courier
              New,Courier,monospace;">HOP</span> instruction is
            used.&nbsp; See also <span style="font-family: Courier
              New,Courier,monospace;">CDS</span> and <span
              style="font-family: Courier New,Courier,monospace;">TRA</span>.<br>
            <br>
            Although the machine instruction requires the address of the
            HOP constant to be provided as its operand, the assembler is
            flexible enough to allow the operand to instead be a
            left-hand symbol for the target location in the code.&nbsp;
            When it encounters this situation, the assembler
            transparently performs a workaround.&nbsp; For the sake of
            discussion, imagine assembly-language code something like
            the following:<br>
            <blockquote><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt><tt>HOP&nbsp;&nbsp;&nbsp;&nbsp;




















                HIGTHR<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .<br>
                HIGTHR&nbsp; ... <i>more code</i> ...<br>
              </tt> </blockquote>
            What the assembler does in a case like this is:<br>
            <ul>
            </ul>
            <ol>
              <li><strike>If the target address </strike><strike>is in
                  the current instruction-memory sector (either in the
                  same or the opposite syllable), transparently replace
                  the </strike><strike><tt>HOP</tt></strike><strike>
                  instruction by a </strike><strike><tt>TRA</tt></strike><strike>
                  instruction.&nbsp; Otherwise, proceed to step 2.</strike><strike><br>
                </strike> </li>
              <li>Allocate a data word in the current data sector.&nbsp;
                Do this by searching upward in the data sector, looking
                for the first unused location.&nbsp; The residual sector
                is searched if there's no room left in the current
                sector.<br>
              </li>
              <li>Create a HOP constant for the target location<tt></tt>,
                and store it in the newly-allocated data word.</li>
              <li>Use the address of the newly-allocated data word as
                the operand for the <tt>HOP</tt> instruction.</li>
            </ol>
            Whenever such a substitution was performed by the assembler,
            it noted it in the assembly listing by printing "<tt>HOP*</tt>"
            as the name of the instruction rather than "<tt>HOP</tt>" as
            what would have been used on the actual punch card.
            <ul>
            </ul>
          </td>
        </tr>
        <tr>
          <td style="font-family: Courier New,Courier,monospace;"> MPY<br>
          </td>
          <td>X<br>
          </td>
          <td>X<br>
          </td>
          <td>0<br>
          </td>
          <td>0<br>
          </td>
          <td>0<br>
          </td>
          <td>1<br>
          </td>
          <td style="text-align: center;">1<br>
            (results<br>
            available after 4)<br>
          </td>
          <td>LVDC only ... <i>not</i> PTC.<br>
            <br>
            This is a multiplication instruction.&nbsp; It multiplies
            two 24-bit numbers to produce a 26-bit product.&nbsp; The
            accumulator provides the address of one operand, and the
            address embedded in the instruction points to the other
            operand.&nbsp; Recall that A1-A8 select the offset within a
            256-word sector, and A9 is the "residual bit" that selects
            between the current sector and the "residual sector".&nbsp;
            In both cases, the most-significant 24-bits of the operands
            are used, and the least-significant 2 bits of the operand
            are ignored.&nbsp; A partial product (24 bits from the
            addressed memory times the 12 less-significant bits from the
            accumulator) can be fetched from the P-Q Register (0775
            octal) on the 2nd instruction (or more accurately, two
            computer cycles) following <span style="font-family:
              Courier New,Courier,monospace;">MPY</span>, though there
            is no need to do so if that value isn't desired by the
            program.&nbsp; The full product is available from the
            accumulator or from the P-Q Register on the 4th instruction
            (more accurately, 4 computer cycles) following <span
              style="font-family: Courier New,Courier,monospace;">MPY</span>.&nbsp;
However,












































































            the result will remain in the P-Q register until the next <span
              style="font-family: Courier New,Courier,monospace;">MPH</span>,
            <span style="font-family: Courier New,Courier,monospace;">MPY</span>,
            or <span style="font-family: Courier
              New,Courier,monospace;">DIV</span>.&nbsp;</td>
        </tr>
        <tr>
          <td valign="middle"><font face="Courier New, Courier,
              monospace">PRS</font><br>
          </td>
          <td valign="middle">X<br>
          </td>
          <td valign="middle">X<br>
          </td>
          <td valign="middle">0<br>
          </td>
          <td valign="middle">0<br>
          </td>
          <td valign="middle">0<br>
          </td>
          <td valign="middle">1<br>
          </td>
          <td valign="middle" align="center">TBD<br>
          </td>
          <td valign="middle">PTC only ... <i>not</i> LVDC<br>
            <br>
            This is a "print store" operation.&nbsp; Here's what <a
              href="Documents/19730064346_1973064346.pdf">the PTC
              documentation (see p. V-2-22)</a> has to say about
            it:&nbsp; Initiates a printer operation. The printer
            operation performed is specified by the operand address. <br>
            <blockquote>
              <table cellspacing="2" cellpadding="2" align="center">
                <tbody>
                  <tr>
                    <td valign="middle" align="center"><u>Address</u><br>
                    </td>
                    <td valign="middle" align="center"><u>Operation</u><br>
                    </td>
                  </tr>
                  <tr>
                    <td valign="middle" align="center">000<sub>8</sub>
                      to 773<sub>8</sub><br>
                    </td>
                    <td valign="middle">Data in memory address specified
                      is transferred to the printer.<br>
                    </td>
                  </tr>
                  <tr>
                    <td valign="middle" align="center">774<sub>8</sub><br>
                    </td>
                    <td valign="middle">A group markword mark is sent to
                      the printer.<br>
                    </td>
                  </tr>
                  <tr>
                    <td valign="middle" align="center">775<sub>8</sub><br>
                    </td>
                    <td valign="middle">Data in the accumulator is
                      transferred to the printer.<br>
                    </td>
                  </tr>
                </tbody>
              </table>
            </blockquote>
            I believe that the data transferred to the printer is often
            buffered by the <tt>BCI</tt> pseudo-op.<br>
          </td>
        </tr>
        <tr>
          <td style="font-family: Courier New,Courier,monospace;"> SUB<br>
          </td>
          <td>X<br>
          </td>
          <td>X<br>
          </td>
          <td>0<br>
          </td>
          <td>0<br>
          </td>
          <td>1<br>
          </td>
          <td>0<br>
          </td>
          <td style="text-align: center;">1<br>
          </td>
          <td>Subtracts the contents of a word pointed to by the address
            embedded within the instruction from the accumulator, and
            puts the result back into the accumulator.&nbsp; Recall that
            A1-A8 select the offset within a 256-word sector, and A9 is
            the "residual bit" that selects between the current sector
            and the "residual sector".&nbsp; See also <span
              style="font-family: Courier New,Courier,monospace;">RSU</span>.<br>
            <br>
            Regarding borrow from the operation, the CPU provides no
            direct way of accessing it, and thus no easy way to perform
            multi-precision subtraction.&nbsp; Refer to the notes for
            the <tt>ADD</tt> instruction for more information.<br>
          </td>
        </tr>
        <tr>
          <td style="font-family: Courier New,Courier,monospace;"> DIV<br>
          </td>
          <td>X<br>
          </td>
          <td>X<br>
          </td>
          <td>0<br>
          </td>
          <td>0<br>
          </td>
          <td>1<br>
          </td>
          <td>1<br>
          </td>
          <td style="text-align: center;">1<br>
            (results<br>
            available<br>
            after 8)</td>
          <td>LVDC only ... <i>not</i> PTC.<br>
            <br>
            This is the division instruction.&nbsp; The contents of the
            accumulator are divided by the operand pointed to by the
            address A1-A9 embedded within the instruction to produce a
            24-bit quotient.&nbsp; Recall that A1-A8 select the offset
            within a 256-word sector, and A9 is the "residual bit" that
            selects between the current sector and the "residual
            sector".&nbsp; The quotient is available in the P-Q Register
            (0775 octal) on the 8th instruction (more accurately, 8
            computer cycles) following the <span style="font-family:
              Courier New,Courier,monospace;">DIV</span>.&nbsp; However,
            the result will remain in the P-Q register until the next <span
              style="font-family: Courier New,Courier,monospace;">MPH</span>,
            <span style="font-family: Courier New,Courier,monospace;">MPY</span>,
            or <span style="font-family: Courier
              New,Courier,monospace;">DIV</span>.</td>
        </tr>
        <tr>
          <td style="font-family: Courier New,Courier,monospace;"> TNZ<br>
          </td>
          <td>X<br>
          </td>
          <td>X<br>
          </td>
          <td>0<br>
          </td>
          <td>1<br>
          </td>
          <td>0<br>
          </td>
          <td>0<br>
          </td>
          <td style="text-align: center;">1<br>
          </td>
          <td>This is a conditional jump instruction, which branches to
            the address embedded in the instruction if the accumulator
            is not zero, but simply continues to the next instruction in
            sequence if the accumulator is zero.&nbsp; Bits A1-A8 of the
            embedded address represent the new offset within the
            currently selected 256-word instruction sector, while bit A9
            gives the syllable number within that word.&nbsp;&nbsp; The
            "residual sector" cannot be accessed.&nbsp; See also <span
              style="font-family: Courier New,Courier,monospace;">TMI</span>.<br>
            <br>
            As mentioned, the target address for the machine instruction
            itself had to be within the current sector, because its
            8-bit address offset is embedded within the
            instruction.&nbsp; However, the assembler would
            transparently work around this problem, allowing essentially
            <i>any</i> target address to be used.&nbsp; For the sake of
            discussion, imagine an assembly language instruction,<br>
            <blockquote><tt>TNZ&nbsp;&nbsp;&nbsp; OINIT</tt><br>
            </blockquote>
            in which the target location <tt>OINIT</tt> is not in the
            current memory sector.&nbsp; The workaround procedure used
            by the assembler was this:<br>
            <ol>
              <li>Working downward from the top of the current
                instruction-memory sector, find an unallocated memory
                location.</li>
              <li>In that newly-allocated memory location, put a "<tt>HOP





























                  OINIT</tt>" instruction.</li>
              <li>Use the newly-allocated memory location as the target
                of the <tt>TNZ</tt> instruction.</li>
              <li>In the assembly listing, display the operator as "<tt>TNZ*</tt>"
                rather than "<tt>TNZ</tt>".&nbsp; (But "<tt>TNZ</tt>" is
                nevertheless what actually appeared on the punch cards.)<br>
              </li>
            </ol>
            Of course, this workaround preserves the intended logic, at
            the cost of an extra instruction word and a couple of extra
            machine cycles.<br>
          </td>
        </tr>
        <tr>
          <td style="font-family: Courier New,Courier,monospace;"> MPH<br>
          </td>
          <td>X<br>
          </td>
          <td>X<br>
          </td>
          <td>0<br>
          </td>
          <td>1<br>
          </td>
          <td>0<br>
          </td>
          <td>1<br>
          </td>
          <td style="text-align: center;">5<br>
          </td>
          <td>LVDC only ... <i>not</i> PTC.<br>
            <br>
            This is a multiplication instruction.&nbsp; It is exactly
            like <span style="font-family: Courier
              New,Courier,monospace;">MPY</span> except that the program
            "holds" until the multiplication is complete, so that the
            product is available from the accumulator or from the P-Q
            Register at the next instruction following <span
              style="font-family: Courier New,Courier,monospace;">MPY</span>.&nbsp;
However,












































































            the result will remain in the P-Q register until the next <span
              style="font-family: Courier New,Courier,monospace;">MPH</span>,
            <span style="font-family: Courier New,Courier,monospace;">MPY</span>,
            or <span style="font-family: Courier
              New,Courier,monospace;">DIV</span>.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle"><font face="Courier New, Courier,
              monospace">CIO</font><br>
          </td>
          <td valign="middle">X<br>
          </td>
          <td valign="middle">X<br>
          </td>
          <td valign="middle">0<br>
          </td>
          <td valign="middle">1<br>
          </td>
          <td valign="middle">0<br>
          </td>
          <td valign="middle">1<br>
          </td>
          <td valign="middle" align="center">TBD<br>
          </td>
          <td valign="middle">PTC only ... <i>not</i> LVDC.<br>
            <br>
            Here's what <a href="Documents/19730064346_1973064346.pdf">the


              PTC documentation (see figure 2-10)</a> has to say about
            it:
            <meta http-equiv="content-type" content="text/html;
              charset=UTF-8">
            "Controls the input, output operations of the CPU. The
            operand address bits specify the operation to be performed
            <meta http-equiv="content-type" content="text/html;
              charset=UTF-8">
            (see figure 2-11 for CIO codes used by PTC)."</td>
        </tr>
        <tr>
          <td style="font-family: Courier New,Courier,monospace;"> AND<br>
          </td>
          <td>X<br>
          </td>
          <td>X<br>
          </td>
          <td>0<br>
          </td>
          <td>1<br>
          </td>
          <td>1<br>
          </td>
          <td>0<br>
          </td>
          <td style="text-align: center;">1<br>
          </td>
          <td>Logically ANDs the contents of the accumulator with the
            contents of the address embedded within the instruction and
            places the result in the accumulator.&nbsp; Recall that
            A1-A8 select the offset within a 256-word sector, and A9 is
            the "residual bit" that selects between the current sector
            and the "residual sector".</td>
        </tr>
        <tr>
          <td style="font-family: Courier New,Courier,monospace;"> ADD<br>
          </td>
          <td>X<br>
          </td>
          <td>X<br>
          </td>
          <td>0<br>
          </td>
          <td>1<br>
          </td>
          <td>1<br>
          </td>
          <td>1<br>
          </td>
          <td style="text-align: center;">1<br>
          </td>
          <td style="vertical-align: top;">Adds the contents of the
            accumulator with the contents of the address embedded within
            the instruction and places the result in the
            accumulator.&nbsp; Recall that A1-A8 select the offset
            within a 256-word sector, and A9 is the "residual bit" that
            selects between the current sector and the "residual
            sector".<br>
            <br>
            What about the carry bit?&nbsp; As far as I can tell, the
            CPU has no provision for carry bit that's useful at the
            software level.&nbsp; If you want to do multi-word precision
            arithmetic (say, 52-bit addition instead of just 26-bit
            addition), then you have to find some indirect,
            software-only way of detecting carry rather than on relying
            on the CPU to provide you with some easy way of handling
            it.&nbsp; It's certainly mathematically possible to do
            so:&nbsp; When adding two addends of the <i>same</i> sign
            using 2's-complement arithmetic, you can detect carry
            because the sum has the opposite sign of the addends,
            whereas adding two addends of <i>opposite</i> signs cannot
            result in carry anyway.&nbsp; But the coding to exploit this
            mathematical possibility is obviously going to be cumbersome
            and inconvenient.&nbsp; (The low-level adder circuit itself
            can deal with a carry bit, of course.&nbsp; The adder
            performs additions serially, starting with the
            least-significant bit and moving upward to the
            most-significant, and at each bit-stage there's a carry bit
            from the previous stage to worry about.&nbsp; However, the
            final carry bit is not accessible to software, and the
            carry-bit latch is cleared by any <tt>CLA</tt> instruction,
            making it very tough to transfer the carry-bit latch's
            contents from one word-addition to the next.&nbsp; In
            theory, if you could figure out a way to do multi-precision
            arithmetic without using <tt>CLA</tt>, perhaps you could
            exploit that hidden carry bit.&nbsp; But I'm having trouble
            seeing any way you might do it.&nbsp; That could just be my
            failure of imagination, of course.)<br>
          </td>
        </tr>
        <tr>
          <td style="font-family: Courier New,Courier,monospace;"> TRA<br>
          </td>
          <td>X<br>
          </td>
          <td>X<br>
          </td>
          <td>1<br>
          </td>
          <td>0<br>
          </td>
          <td>0<br>
          </td>
          <td>0<br>
          </td>
          <td style="text-align: center;">1<br>
          </td>
          <td style="vertical-align: top;">Note that there is also a <a
              href="#Pseudo-ops">pseudo-op</a>, <tt>TRA**</tt>, which
            is not a <tt>TRA</tt> instruction, although it has a
            similar effect at assembly time to the effect the affect of
            the <tt>TRA</tt> instruction at runtime.<tt><br>
              <br>
              TRA</tt> is an unconditional jump instruction, which
            branches to the address embedded in the instruction.&nbsp;
            Bits A1-A8 of the embedded address represent the new offset
            within the currently selected 256-word instruction sector,
            while bit A9 gives the syllable number within that
            word.&nbsp;&nbsp; The "residual sector" cannot be accessed.<br>
            <br>
            Note, however, that the <i>assembler</i> transparently
            worked around the limitation that the target address had to
            be in the same sector.&nbsp; The assembler would
            automatically insert a <tt>HOP</tt> instruction instead of
            a <tt>TRA</tt> whenever it found that it was necessary to
            do so.&nbsp; For example, consider the instruction "<tt>TRA
              ETCBTC</tt>".&nbsp; If the target location <tt>ETCBTC</tt>
            is within the current instruction sector, the assembler
            would indeed assemble this exact as expected, using a <tt>TRA</tt>
            instruction with opcode <tt>1000</tt>.&nbsp; Actually, the
            assembler would refuse to directly do a <tt>TRA</tt> to a
            target in the same instruction sector under some
            circumstances, presumably to help guard the programmer from
            easy-to-make errors.&nbsp; The condition I've noticed in
            which this occurs is if the target address has been tagged
            by the assembler as being in a region with a different
            setting for the <i>data</i> module or sector, since unlike
            a <tt>HOP</tt> instruction, a <tt>TRA</tt> instruction
            doesn't alter the DM/DS settings.&nbsp; Whereas if a <tt>CDS</tt>
            instruction (which changes the DM/DS settings in the
            processor itself) happens to be at the target location, it
            doesn't trigger a replacement by <tt>HOP</tt>.&nbsp; Quite
            a complicated set of conditions! One wonders if the original
            programmers actually had much awareness at the time (or
            cared!) that these substitutions were being made for them.<br>
            <br>
            But if the target location (<tt>ETCBTC</tt> in this example)
            wasn't within the current instruction sector or failed the
            DM/DS conditions, then the assembler would instead perform
            the following complicated maneuver which preserves the
            expected program logic, at the cost of an extra machine
            cycle and an extra word of memory:<br>
            <ul>
              <li>Allocate a data word in the current data sector.&nbsp;
                This is done by searching upward through the current
                data sector (or the residual sector, failing that) until
                an unallocated word is found.<br>
              </li>
              <li>Create a HOP constant for the target location <tt>ETCBTC</tt>,
                and store it in the newly-allocated data word.</li>
              <li>Assemble a <tt>HOP</tt> instruction with the
                newly-allocated data word as its operand.</li>
              <li>Whenever such a substitution was performed by the
                assembler, it noted it in the assembly listing by
                replacing "<tt>TRA</tt>" with "<tt>TRA*</tt>".&nbsp;
                However, I think that "<tt>TRA</tt>" is always what
                would have originally been used on the punch card.<br>
              </li>
            </ul>
            This in so far as the assembly-language source code is
            concerned, it seems that one may as well always use <tt>TRA</tt>
            rather than <tt>HOP</tt>, since <tt>TRA</tt> is more
            economical than <tt>HOP</tt>, and the assembler will always
            substitute <tt>HOP</tt> anyway whenever some limitation of
            <tt>TRA</tt> necessitates it.<br>
          </td>
        </tr>
        <tr>
          <td style="font-family: Courier New,Courier,monospace;"> XOR<br>
          </td>
          <td>X<br>
          </td>
          <td>X<br>
          </td>
          <td>1<br>
          </td>
          <td>0<br>
          </td>
          <td>0<br>
          </td>
          <td>1<br>
          </td>
          <td style="text-align: center;">1<br>
          </td>
          <td style="vertical-align: top;">Logically exclusive-ORs the
            contents of the accumulator with the contents of the address
            embedded within the instruction and places the result in the
            accumulator.&nbsp;Recall that A1-A8 select the offset within
            a 256-word sector, and A9 is the "residual bit" that selects
            between the current sector and the "residual sector".</td>
        </tr>
        <tr>
          <td style="font-family: Courier New,Courier,monospace;"> PIO<br>
          </td>
          <td>X<br>
          </td>
          <td>X<br>
          </td>
          <td>1<br>
          </td>
          <td>0<br>
          </td>
          <td>1<br>
          </td>
          <td>0<br>
          </td>
          <td style="text-align: center;">1<br>
          </td>
          <td style="vertical-align: top;">Reads or writes an i/o
            port.&nbsp;&nbsp;&nbsp; Bits A1-A9 select the source and
            destination of the i/o.&nbsp;&nbsp; A table of the i/o ports
            vs. addresses is given in the <a
              href="#IO_Ports_For_PIO_Instruction">following section</a>.<br>
            <br>
            In so far as assembly-language syntax is concerned, the
            operand of the instruction is always a literal octal
            numerical constant.<br>
          </td>
        </tr>
        <tr>
          <td style="font-family: Courier New,Courier,monospace;"> STO<br>
          </td>
          <td>X<br>
          </td>
          <td>X<br>
          </td>
          <td>1<br>
          </td>
          <td>0<br>
          </td>
          <td>1<br>
          </td>
          <td>1<br>
          </td>
          <td style="text-align: center;">1<br>
          </td>
          <td style="vertical-align: top;"> Stores the contents of the
            accumulator in the word indicated by the address embedded
            within the instruction.&nbsp; Recall that A1-A8 select the
            offset within a 256-word sector, and A9 is the "residual
            bit" that selects between the current sector and the
            "residual sector".&nbsp; The following addresses are
            special, as described in <a
href="Documents/LaboratoryMaintenanceInstructionsForLVDC-Volume1-GeneralDescriptionAndTheory.pdf">the


































































              documentation of the STO instruction (see p. 2-17)</a>:<br>
            <ul>
              <li>0775 (octal) stores into the Product-Quotient register
                rather than to normal memory.</li>
              <li>0776 (octal) stores the contents of the
                multiplicand-divisor register (rather than the
                accumulator) to address 0776.</li>
              <li>0777 (octal) stores the contents of the
                multiplicand-divisor register (rather than the
                accumulator) to address 0777.</li>
            </ul>
            <p>However, the description of 0776 and 0777 above is quite
              misleading.&nbsp; For one thing, the way the
              multiplication and division instructions work, the inputs
              to those operations (multiplicand, multiplier, dividend,
              divisor) are all supplied in the accumulator and memory
              locations anyway, so why would you need an instruction to
              separately access the multiplicand or divisor?&nbsp; The
              answer is that this feature has nothing at all to do with
              multiplication and division, but is instead crucial to
              storing return addresses in subroutines and interrupts!<br>
            </p>
            <p>The explanation is this:&nbsp; During the process of
              executing any given LVDC instruction, a HOP constant for
              the LVDC instruction at the <i>next successive memory
                address</i> is formed.&nbsp; Keep in mind that the next
              instruction successively in memory is not necessarily the
              next instruction sequentially executed in time.&nbsp;
              Whatever the next instruction executed — unless it happens
              to be a multiplication or division (<tt>MPY</tt>, <tt>MPH</tt>,
              <tt>DIV</tt>) — the previously-generated HOP constant is
              temporarily shoved into multiplicand-divisor
              register.&nbsp; Thus if the very next instruction executed
              is <tt>STO 776</tt> or <tt>STO 777</tt> (and the
              previous instruction was <i>not</i> <tt>MPY</tt>, <tt>MPH</tt>,
              or <tt>DIV</tt>), what ends up getting stored in location
              776 or 777 is not a multiplicand or divisor, but rather
              the HOP constant for the memory address that numerically
              follows the <i>previously executed</i> instruction.&nbsp;
              Which is not useful at all when instructions are simply
              executing sequentially, but is useful whenever there is a
              transfer of control because the code to which control has
              been transferred can use it to access its own return
              address ... and there is no other painless method provided
              in the instruction set to do so.<br>
            </p>
            <blockquote>
              <p><b>In other words, in a subroutine or interrupt-service
                  routine, the very first instruction should be a </b><b>
                </b><b><tt>STO 776</tt></b><b> or </b><b><tt>STO 777</tt></b><b>
                  to save the HOP constant for the return address.&nbsp;
                  Conversely, the instruction for returning from the
                  subroutine or interrupt is a matching </b><b><tt>HOP
                    776</tt></b><b> or </b><b><tt>HOP</tt></b><b><tt>
                    777</tt></b><b> instruction.</b><br>
              </p>
            </blockquote>
            <ul>
            </ul>
          </td>
        </tr>
        <tr>
          <td style="font-family: Courier New,Courier,monospace;"> TMI<br>
          </td>
          <td>X<br>
          </td>
          <td>X<br>
          </td>
          <td>1<br>
          </td>
          <td>1<br>
          </td>
          <td>0<br>
          </td>
          <td>0<br>
          </td>
          <td style="text-align: center;">1<br>
          </td>
          <td style="vertical-align: top;">This is a conditional jump
            instruction, which branches to the address embedded in the
            instruction if the accumulator is less than zero, but simply
            continues to the next instruction in sequence if the
            accumulator greater than or equal to zero.&nbsp; Bits A1-A8
            of the embedded address represent the new offset within the
            currently selected 256-word instruction sector, while bit A9
            gives the syllable number within that word.&nbsp;&nbsp; The
            "residual sector" cannot be accessed.&nbsp; See also <span
              style="font-family: Courier New,Courier,monospace;">TNZ</span>.<br>
            <br>
            As mentioned, the target address for the machine instruction
            itself had to be within the current sector, because its
            8-bit address offset is embedded within the
            instruction.&nbsp; However, the assembler would
            transparently work around this problem, allowing essentially
            <i>any</i> target address to be used.&nbsp; The workaround
            used by the assembler is that same as that described for the
            <tt>TNZ</tt> instruction above.&nbsp; Instructions for which
            the workaround have been applied are shown on the assembly
            listing as "<tt>TMI*</tt>" rather than "<tt>TMI</tt>".<br>
          </td>
        </tr>
        <tr>
          <td style="font-family: Courier New,Courier,monospace;"> RSU<br>
          </td>
          <td>X<br>
          </td>
          <td>X<br>
          </td>
          <td>1<br>
          </td>
          <td>1<br>
          </td>
          <td>0<br>
          </td>
          <td>1<br>
          </td>
          <td style="text-align: center;">1<br>
          </td>
          <td style="vertical-align: top;">Same as SUB, except that the
            order of the operands in the subtraction is reversed.<br>
          </td>
        </tr>
        <tr>
          <td style="font-family: Courier New,Courier,monospace;"> CDS<br>
            <i><font face="Helvetica, Arial, sans-serif">or</font></i><br>
            CDSD<br>
            <i>or</i><br>
            CDSS<br>
          </td>
          <td>X<br>
          </td>
          <td>0<br>
          </td>
          <td>1<br>
          </td>
          <td>1<br>
          </td>
          <td>1<br>
          </td>
          <td>0<br>
          </td>
          <td style="text-align: center;">1<br>
          </td>
          <td style="vertical-align: top;"> Change the
            currently-selected 256-word data sector.&nbsp; For this
            instruction, A9 forms a part of the instruction itself, so
            only A1-A8 are significant.&nbsp; The partially overwrite
            the HOP Register as follows:<br>
            <br>
            <div style="text-align: center;"> <img style="width: 345px;
                height: 283px;" alt="" src="LVDC-CdsInstruction.jpg"
                width="345" height="283"><br>
              <div style="text-align: left;"> <br>
                See also <span style="font-family: Courier
                  New,Courier,monospace;">HOP</span>.<br>
                <br>
                In terms of assembly-language syntax, there are the
                following variations:<br>
                <blockquote><tt>CDS&nbsp;&nbsp;&nbsp;&nbsp; <i></i><i>SYMBOLNAME</i></tt><tt><br>
                  </tt><tt>CDSD&nbsp;&nbsp;&nbsp; <i>DM,DS</i></tt><tt><br>
                  </tt><tt>CDSS&nbsp;&nbsp;&nbsp; <i>DM,DS</i></tt><br>
                </blockquote>
                Thus <tt>CDS</tt> uses the characteristics of a
                variable name or a name defined with the <tt>DEQD</tt>
                or <tt>DEQS</tt> pseudo-ops (see below), whereas the
                module number and sector number are simply supplied with
                octal numeric literals in <tt>CDSD</tt> or <tt>CDSS</tt>.&nbsp;




























                The difference between <tt>CDSD</tt> and <tt>CDSS</tt>
                is that the former selects duplex memory while the later
                selects simplex memory.<br>
                <br>
                In the usage I've seen, usage of <tt>CDSS</tt> is
                confined almost entirely to the context of <tt>USE DAT</tt>
                (see below).<br>
              </div>
            </div>
          </td>
        </tr>
        <tr>
          <td style="font-family: Courier New,Courier,monospace;"> SHF<br>
          </td>
          <td>0<br>
          </td>
          <td>1<br>
          </td>
          <td>1<br>
          </td>
          <td>1<br>
          </td>
          <td>1<br>
          </td>
          <td>0<br>
          </td>
          <td style="text-align: center;">1<br>
          </td>
          <td style="vertical-align: top;"> Performs a logical shift
            operation on the accumulator.&nbsp; For this instruction,
            bits A8 and A9 form a part of the instruction itself, but of
            the remaining bits only A1, A2, A5, and A6 are actually
            used, as follows:<br>
            <br>
            <table summary="" style="text-align: left; margin-left:
              auto; margin-right: auto;" cellspacing="2" cellpadding="2"
              border="1">
              <tbody>
                <tr>
                  <th style="vertical-align: top; font-weight: bold;">
                    A1<br>
                  </th>
                  <th style="vertical-align: top; font-weight: bold;">
                    A2<br>
                  </th>
                  <th style="vertical-align: top; font-weight: bold;">
                    A5<br>
                  </th>
                  <th style="vertical-align: top; font-weight: bold;">
                    A6<br>
                  </th>
                  <th style="vertical-align: top; font-weight: bold;">
                    Description of operation<br>
                  </th>
                </tr>
                <tr>
                  <td style="vertical-align: top;">0<br>
                  </td>
                  <td style="vertical-align: top;">0<br>
                  </td>
                  <td style="vertical-align: top;">0<br>
                  </td>
                  <td style="vertical-align: top;">0<br>
                  </td>
                  <td style="vertical-align: top;">Clears the
                    accumulator<br>
                  </td>
                </tr>
                <tr>
                  <td style="vertical-align: top;">1<br>
                  </td>
                  <td style="vertical-align: top;">0<br>
                  </td>
                  <td style="vertical-align: top;">0<br>
                  </td>
                  <td style="vertical-align: top;">0<br>
                  </td>
                  <td style="vertical-align: top;">Shift one position
                    towards in the less-significant direction<br>
                  </td>
                </tr>
                <tr>
                  <td style="vertical-align: top;">0<br>
                  </td>
                  <td style="vertical-align: top;">1<br>
                  </td>
                  <td style="vertical-align: top;">0<br>
                  </td>
                  <td style="vertical-align: top;">0<br>
                  </td>
                  <td style="vertical-align: top;">Shift two positions
                    towards in the less-significant direction</td>
                </tr>
                <tr>
                  <td style="vertical-align: top;">0<br>
                  </td>
                  <td style="vertical-align: top;">0<br>
                  </td>
                  <td style="vertical-align: top;">1<br>
                  </td>
                  <td style="vertical-align: top;">0<br>
                  </td>
                  <td style="vertical-align: top;">Shift one position
                    towards in the more-significant direction</td>
                </tr>
                <tr>
                  <td style="vertical-align: top;">0<br>
                  </td>
                  <td style="vertical-align: top;">0<br>
                  </td>
                  <td style="vertical-align: top;">0<br>
                  </td>
                  <td style="vertical-align: top;">1<br>
                  </td>
                  <td style="vertical-align: top;">Shift two positions
                    towards in the more-significant direction</td>
                </tr>
              </tbody>
            </table>
            <br>
            In terms of assembly-language syntax, I have never seen <tt>SHF</tt>
            itself used.&nbsp; The only variations actually used are<br>
            <blockquote><tt>SHL <i>N</i></tt><tt><br>
              </tt><tt>SHR <i>N</i></tt><br>
            </blockquote>
            where <i><tt>N</tt></i> is a literal decimal numerical
            constant.&nbsp; However, <tt>N</tt> is not limited to just
            0, 1, or 2, even those are all that <tt>SHF</tt> directly
            supports.&nbsp; If an operand <i><tt>N</tt></i>&gt;2 is
            encountered, the assembler transparently replaces it with an
            appropriates sequence of shift-by-2 and shift-by-1
            instructions.<br>
          </td>
        </tr>
        <tr>
          <td style="font-family: Courier New,Courier,monospace;"> EXM<br>
          </td>
          <td>1<br>
          </td>
          <td>1<br>
          </td>
          <td>1<br>
          </td>
          <td>1<br>
          </td>
          <td>1<br>
          </td>
          <td>0<br>
          </td>
          <td style="text-align: center;">1<br>
          </td>
          <td style="vertical-align: top;"> LVDC only ... <i>not</i>
            PTC.<br>
            <br>
            "Execute modified".&nbsp; This instruction takes an
            instruction stored at a specified memory location, forms a
            modified A1-A9 field for that instruction, executes that
            instruction, and then continues with the next instruction
            following the <span style="font-family: Courier
              New,Courier,monospace;">EXM</span> (unless the program
            counter has been modified).&nbsp; For this instruction, A8
            and A9 form a part of the instruction code, so only A1-A7
            are significant.&nbsp; Only 4 different target words are
            allowed, 0600, 0640, 0700, and 0740, and they are all in the
            "residual sector".&nbsp; Many of the bits in A1-A7 represent
            various types of modifications to the embedded address at
            the target address rather than being address bits
            themselves.&nbsp;&nbsp; Here are the interpretations of bits
            A1-A7 in the <span style="font-family: Courier
              New,Courier,monospace;">EXM</span> instruction:<br>
            <ul>
              <li>A1-A4 modify the address embedded in the target
                instruction as described below.<br>
              </li>
              <li>A5 indicates the syllable in which the target
                instruction resides.</li>
              <li>A7,A6 selects the target address, as follows:</li>
              <ul>
                <li>0,0 for target address 0600</li>
                <li>0,1 for target address 0640</li>
                <li>1,0 for target address 0700</li>
                <li>1,1 for target address 0740</li>
              </ul>
            </ul>
            When the target instruction is executed, its A1-A9 bits are
            formed as follows:<br>
            <ul>
              <li>A1-A2 come from A1-A2 of the <span
                  style="font-family: monospace;">EXM</span>
                instruction.</li>
              <li>A3 is the logical OR of the A3 of the target
                instruction and A3 of the <span style="font-family:
                  Courier New,Courier,monospace;">EXM</span>
                instruction.</li>
              <li>A4 is the logical OR of the A4 of the target
                instruction and A4 of the <span style="font-family:
                  Courier New,Courier,monospace;">EXM</span>
                instruction.</li>
              <li>A5-A8 come from A5-A8 of the target instruction.</li>
            </ul>
            The data sector used when the target instruction is executed
            is also changed for the duration of that one instruction, as
            determined by bits A1, A2, and A9 of the unmodified target
            instruction, as follows:<br>
            <br>
            <table summary="" style="text-align: left; margin-left:
              auto; margin-right: auto;" cellspacing="2" cellpadding="2"
              border="1">
              <tbody>
                <tr>
                  <th style="vertical-align: top; font-weight: bold;">
                    A2<br>
                  </th>
                  <th style="vertical-align: top; font-weight: bold;">
                    A1<br>
                  </th>
                  <th style="vertical-align: top; font-weight: bold;">
                    A9<br>
                  </th>
                  <th style="vertical-align: top; font-weight: bold;">Data












































































                    Sector<br>
                  </th>
                </tr>
                <tr>
                  <td style="vertical-align: top;">0<br>
                  </td>
                  <td style="vertical-align: top;">0<br>
                  </td>
                  <td style="vertical-align: top;">0<br>
                  </td>
                  <td style="vertical-align: top;">004<br>
                  </td>
                </tr>
                <tr>
                  <td style="vertical-align: top;">0<br>
                  </td>
                  <td style="vertical-align: top;">0<br>
                  </td>
                  <td style="vertical-align: top;">1<br>
                  </td>
                  <td style="vertical-align: top;">014<br>
                  </td>
                </tr>
                <tr>
                  <td style="vertical-align: top;">0<br>
                  </td>
                  <td style="vertical-align: top;">1<br>
                  </td>
                  <td style="vertical-align: top;">0<br>
                  </td>
                  <td style="vertical-align: top;">005<br>
                  </td>
                </tr>
                <tr>
                  <td style="vertical-align: top;">0<br>
                  </td>
                  <td style="vertical-align: top;">1<br>
                  </td>
                  <td style="vertical-align: top;">1<br>
                  </td>
                  <td style="vertical-align: top;">015<br>
                  </td>
                </tr>
                <tr>
                  <td style="vertical-align: top;">1<br>
                  </td>
                  <td style="vertical-align: top;">0<br>
                  </td>
                  <td style="vertical-align: top;">0<br>
                  </td>
                  <td style="vertical-align: top;">006<br>
                  </td>
                </tr>
                <tr>
                  <td style="vertical-align: top;">1<br>
                  </td>
                  <td style="vertical-align: top;">0<br>
                  </td>
                  <td style="vertical-align: top;">1<br>
                  </td>
                  <td style="vertical-align: top;">016<br>
                  </td>
                </tr>
                <tr>
                  <td style="vertical-align: top;">1<br>
                  </td>
                  <td style="vertical-align: top;">1<br>
                  </td>
                  <td style="vertical-align: top;">0<br>
                  </td>
                  <td style="vertical-align: top;">007<br>
                  </td>
                </tr>
                <tr>
                  <td style="vertical-align: top;">1<br>
                  </td>
                  <td style="vertical-align: top;">1<br>
                  </td>
                  <td style="vertical-align: top;">1<br>
                  </td>
                  <td style="vertical-align: top;">017 ("residual"
                    sector)<br>
                  </td>
                </tr>
              </tbody>
            </table>
            <br>
            In baseball terms, this is the "infield fly rule" of the
            LVDC: it clearly does something, but it's hard to grasp
            exactly what it does.<br>
          </td>
        </tr>
        <tr>
          <td style="font-family: Courier New,Courier,monospace;"> CLA<br>
          </td>
          <td>X<br>
          </td>
          <td>X<br>
          </td>
          <td>1<br>
          </td>
          <td>1<br>
          </td>
          <td>1<br>
          </td>
          <td>1<br>
          </td>
          <td style="text-align: center;">1<br>
          </td>
          <td style="vertical-align: top;">Store a value to the
            accumulator, from the memory word at the address embedded
            within the instruction.&nbsp;&nbsp; Recall that A1-A8 select
            the offset within a 256-word sector, and A9 is the "residual
            bit" that selects between the current sector and the
            "residual sector".</td>
        </tr>
      </tbody>
    </table>
    <br>
    <h3><a name="IO_Ports_For_PIO_Instruction"
        id="IO_Ports_For_PIO_Instruction"></a>I/O Ports (For <span
        style="font-family: Courier New,Courier,monospace;">PIO</span>
      Instruction)</h3>
    My understanding of this is sketchy right now, so take anything I
    have to say with a grain of salt.<br>
    <br>
    <table summary="" style="text-align: left; width: 100%;"
      cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <th style="text-align: center;" colspan="9" rowspan="1">
            Address Field from PIO Instruction<br>
          </th>
          <th colspan="1" rowspan="2">Data Source<br>
          </th>
          <th colspan="1" rowspan="2">Data Destination<br>
          </th>
          <th colspan="1" rowspan="2" style="vertical-align: middle;">Specific



















            I/O Ports<br>
          </th>
        </tr>
        <tr>
          <th style="text-align: center;">A9<br>
          </th>
          <th style="text-align: center;">A8<br>
          </th>
          <th style="text-align: center;">A7<br>
          </th>
          <th style="text-align: center;">A6<br>
          </th>
          <th style="text-align: center;">A5<br>
          </th>
          <th style="text-align: center;">A4<br>
          </th>
          <th style="text-align: center;">A3<br>
          </th>
          <th style="text-align: center;">A2<br>
          </th>
          <th style="text-align: center;">A1<br>
          </th>
        </tr>
        <tr>
          <td style="text-align: center;" valign="middle" align="center">X<br>
          </td>
          <td style="text-align: center;" valign="middle" align="center">0<br>
          </td>
          <td style="text-align: center;" valign="middle" align="center"><i>
              A</i><i><br>
            </i> </td>
          <td style="text-align: center;" valign="middle" align="center"><i>
              A</i><i><br>
            </i> </td>
          <td style="text-align: center;" valign="middle" align="center"><i>
              A</i><i><br>
            </i> </td>
          <td style="text-align: center;" valign="middle" align="center"><i>
              A</i><i><br>
            </i> </td>
          <td style="text-align: center;" valign="middle" align="center"><i>
              A</i><i><br>
            </i> </td>
          <td style="text-align: center;" valign="middle" align="center">0<br>
          </td>
          <td style="text-align: center;" valign="middle" align="center"><i>A</i><br>
          </td>
          <td valign="middle">LVDC Accumulator Register<br>
          </td>
          <td valign="middle">LVDA Telemetry Registers<span
              style="font-style: italic;"></span><br>
          </td>
          <td colspan="1" rowspan="3" valign="middle">(Note:&nbsp; Used
            to output telemetry consisting of the values of variables,
            typically via the <tt>TELEM</tt> macro in the LVDC source
            code.&nbsp; For definitions of non-standard units of
            measurement, see <a href="#AngleUnits">the later discussion
              of that topic</a>.&nbsp; Page-number references are to the
            AS-206RAM LVDC source code or to its <a
href="https://github.com/virtualagc/virtualagc/blob/master/yaASM.py/sample-1967.lvdc">abridged


















              form</a>.)<br>
            <table width="80%" cellspacing="2" cellpadding="2"
              border="1" align="center">
              <tbody>
                <tr>
                  <th valign="bottom">A9 - A1 (octal)<br>
                  </th>
                  <th valign="bottom">Variable<br>
                  </th>
                  <th valign="bottom">Scale<br>
                  </th>
                  <th valign="bottom">Units<br>
                  </th>
                  <th valign="bottom" align="left">Interpretation<br>
                  </th>
                </tr>
                <tr>
                  <td valign="middle" align="center">000<br>
                  </td>
                  <td valign="middle" align="center"><tt>TASEC</tt><tt><br>
                    </tt><tt>ONTAS</tt><tt><br>
                    </tt> </td>
                  <td valign="middle" align="center"><tt>B15</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">sec<br>
                  </td>
                  <td valign="middle">Time elapsed from GRR or time of
                    last orbit navigation<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">001<br>
                  </td>
                  <td valign="middle" align="center"><tt>CHIZ</tt><tt><br>
                    </tt> </td>
                  <td valign="middle" align="center"><tt>B0</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">pirad<br>
                  </td>
                  <td valign="middle">Yaw guidance command in
                    space-fixed coordinates<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">004<br>
                  </td>
                  <td valign="middle" align="center"><tt>ACCZ</tt><tt><br>
                    </tt> </td>
                  <td valign="middle" align="center"><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">0.05 m/sec<br>
                  </td>
                  <td valign="middle">Accelerator optisyn reading<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">005<br>
                  </td>
                  <td valign="middle" align="center"><tt>CHIX</tt><tt><br>
                    </tt> </td>
                  <td valign="middle" align="center"><tt>B0</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">pirad<br>
                  </td>
                  <td valign="middle">Pitch guidance command in
                    space-fixed coordinates</td>
                </tr>
                <tr>
                  <td valign="middle" align="center">010<br>
                  </td>
                  <td valign="middle" align="center"><tt>ACCX</tt><tt><br>
                    </tt> </td>
                  <td valign="middle" align="center"><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">0.05 m/sec</td>
                  <td valign="middle">Accelerator optisyn reading</td>
                </tr>
                <tr>
                  <td valign="middle" align="center">011<br>
                  </td>
                  <td valign="middle" align="center"><tt>CHIY</tt><tt><br>
                    </tt> </td>
                  <td valign="middle" align="center"><tt>B0</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">pirad<br>
                  </td>
                  <td valign="middle">Roll guidance command in
                    space-fixed coordinates</td>
                </tr>
                <tr>
                  <td valign="middle" align="center">014<br>
                  </td>
                  <td valign="middle" align="center"><tt>ACCY</tt><tt><br>
                    </tt> </td>
                  <td valign="middle" align="center"><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">0.05 m/sec</td>
                  <td valign="middle">Accelerator optisyn reading</td>
                </tr>
                <tr>
                  <td valign="middle" align="center">015<br>
                  </td>
                  <td valign="middle" align="center"><tt>THETZ</tt></td>
                  <td valign="middle" align="center"><tt>B0</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">pirad</td>
                  <td valign="middle">Whole yaw gimbal angle<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">021<br>
                  </td>
                  <td valign="middle" align="center"><tt>THETX</tt><tt><br>
                    </tt> </td>
                  <td valign="middle" align="center"><tt>B0</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">pirad</td>
                  <td valign="middle">Whole roll gimbal angle</td>
                </tr>
                <tr>
                  <td valign="middle" align="center">025<br>
                  </td>
                  <td valign="middle" align="center"><tt>THETY</tt><tt><br>
                    </tt> </td>
                  <td valign="middle" align="center"><tt>B0</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">pirad</td>
                  <td valign="middle">Whole pitch gimbal angle</td>
                </tr>
                <tr>
                  <td valign="middle" align="center">030<br>
                  </td>
                  <td valign="middle" align="center"><tt>TLTBB</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt>B15</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">sec<br>
                  </td>
                  <td valign="middle">Biased time elapsed in time base<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">031<br>
                  </td>
                  <td valign="middle" align="center"><tt>TB</tt><tt><br>
                    </tt> </td>
                  <td valign="middle" align="center"><tt>B15</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">sec<br>
                  </td>
                  <td valign="middle">Time elapsed in current time base<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">034<br>
                  </td>
                  <td valign="middle" align="center"><tt>ZS</tt><tt><br>
                    </tt><tt>ONZN</tt><tt><br>
                    </tt> </td>
                  <td valign="middle" align="center"><tt>B23</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">m<br>
                  </td>
                  <td valign="middle">Component of position in
                    space-fixed coordinates<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">044<br>
                  </td>
                  <td valign="middle" align="center"><tt>XS</tt><tt><br>
                    </tt><tt>ONXN</tt><tt><br>
                    </tt> </td>
                  <td valign="middle" align="center"><tt>B23</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">m<br>
                  </td>
                  <td valign="middle">Component of position in
                    space-fixed coordinates</td>
                </tr>
                <tr>
                  <td valign="middle" align="center">050<br>
                  </td>
                  <td valign="middle" align="center"><tt>Y</tt><tt>S</tt><tt><br>
                    </tt><tt>ONYN</tt><tt><br>
                    </tt> </td>
                  <td valign="middle" align="center"><tt>B23</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">m<br>
                  </td>
                  <td valign="middle">Component of position in
                    space-fixed coordinates</td>
                </tr>
                <tr>
                  <td valign="middle" align="center">054<br>
                  </td>
                  <td valign="middle" align="center"><tt>GR10R</tt><tt><br>
                    </tt> </td>
                  <td valign="middle" align="center"><tt>B-22</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">m<sup>-1</sup></td>
                  <td valign="middle">Reciprocal of total radius in
                    space-fixed coordinates<sup></sup><br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">060<br>
                  </td>
                  <td valign="middle" align="center"><tt>GZ</tt><tt><br>
                    </tt> </td>
                  <td valign="middle" align="center"><tt>B4</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">m/sec<sup>2</sup></td>
                  <td valign="middle">Component of gravitational
                    acceleration<sup></sup><br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">064<br>
                  </td>
                  <td valign="middle" align="center"><tt>GX</tt><tt><br>
                    </tt> </td>
                  <td valign="middle" align="center"><tt>B4</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">m/sec<sup>2</sup></td>
                  <td valign="middle">Component of gravitational
                    acceleration<sup></sup></td>
                </tr>
                <tr>
                  <td valign="middle" align="center">070<br>
                  </td>
                  <td valign="middle" align="center"><tt>GY</tt><tt><br>
                    </tt> </td>
                  <td valign="middle" align="center"><tt>B4</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">m/sec<sup>2</sup></td>
                  <td valign="middle">Component of gravitational
                    acceleration<sup></sup></td>
                </tr>
                <tr>
                  <td valign="middle" align="center">074<br>
                  </td>
                  <td valign="middle" align="center"><tt>TBA</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt>B15</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">sec<br>
                  </td>
                  <td valign="middle">Set equal to TBB at the time of a
                    C-band station gain or loss<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">075<br>
                  </td>
                  <td valign="middle" align="center"><tt>SS</tt><tt><br>
                    </tt> </td>
                  <td valign="middle" align="center"><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><br>
                  </td>
                  <td valign="middle">Switch selector interrupt<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">110<br>
                  </td>
                  <td valign="middle" align="center"><tt>ZDS</tt><tt><br>
                    </tt> </td>
                  <td valign="middle" align="center"><tt>B14</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">m/sec<br>
                  </td>
                  <td valign="middle">Component of velocity in
                    space-fixed coordinates<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">114<br>
                  </td>
                  <td valign="middle" align="center"><tt>XDS</tt><tt><br>
                    </tt> </td>
                  <td valign="middle" align="center"><tt>B14</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">m/sec</td>
                  <td valign="middle">Component of velocity in
                    space-fixed coordinates</td>
                </tr>
                <tr>
                  <td valign="middle" align="center">120<br>
                  </td>
                  <td valign="middle" align="center"><tt>YDS</tt><tt><br>
                    </tt> </td>
                  <td valign="middle" align="center"><tt>B14</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">m/sec</td>
                  <td valign="middle">Component of velocity in
                    space-fixed coordinates</td>
                </tr>
                <tr>
                  <td valign="middle" align="center">124<br>
                  </td>
                  <td valign="middle" align="center"><tt>V</tt><tt><br>
                    </tt> </td>
                  <td valign="middle" align="center"><tt>B14</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">m/sec</td>
                  <td valign="middle">Total velocity in space-fixed
                    coordinates<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">134<br>
                  </td>
                  <td valign="middle" align="center"><tt>ZS</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt>B23</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">m<br>
                  </td>
                  <td valign="middle">Component of position in
                    space-fixed coordinates</td>
                </tr>
                <tr>
                  <td valign="middle" align="center">144<br>
                  </td>
                  <td valign="middle" align="center"><tt>XS</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt>B23</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">m<br>
                  </td>
                  <td valign="middle">Component of position in
                    space-fixed coordinates</td>
                </tr>
                <tr>
                  <td valign="middle" align="center">150<br>
                  </td>
                  <td valign="middle" align="center"><tt>YS</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt>B23</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">m<br>
                  </td>
                  <td valign="middle">Component of position in
                    space-fixed coordinates</td>
                </tr>
                <tr>
                  <td valign="middle" align="center">174<br>
                  </td>
                  <td valign="middle" align="center"><tt>ACCT</tt><tt><br>
                    </tt><tt>TLPAST</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt>B25</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">qms<br>
                  </td>
                  <td valign="middle">Real time clock reading<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">400<br>
                  </td>
                  <td valign="middle" align="center"><tt>T1I</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt>B10</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">sec<br>
                  </td>
                  <td valign="middle">First IGM phase time-to-go<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">414<br>
                  </td>
                  <td valign="middle" align="center"><tt>MC28</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><br>
                  </td>
                  <td valign="middle">Mode code 28 status changes.&nbsp;
                    Refer to p. 12.<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">415<br>
                  </td>
                  <td valign="middle" align="center"><tt>MC24</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><br>
                  </td>
                  <td valign="middle">Mode code 24 status changes.&nbsp;
                    Refer to pp. 4-5.<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">420<br>
                  </td>
                  <td valign="middle" align="center"><tt>MC27</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><br>
                  </td>
                  <td valign="middle">Mode code 27 status changes.&nbsp;
                    Refer to pp. 11-12<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">421<br>
                  </td>
                  <td valign="middle" align="center"><tt>MC25</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><br>
                  </td>
                  <td valign="middle">Mode code 25 status changes.&nbsp;
                    Refer to p. 5.</td>
                </tr>
                <tr>
                  <td valign="middle" align="center">425<br>
                  </td>
                  <td valign="middle" align="center"><tt>DORSW</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><br>
                  </td>
                  <td valign="middle">Discrete output register
                    contents.&nbsp; A change indicates a guidance
                    failure.<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">431<br>
                  </td>
                  <td valign="middle" align="center"><tt>ICR</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><br>
                  </td>
                  <td valign="middle">LVDA internal control register
                    contents.&nbsp; Refer to pp. 5-6.<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">434<br>
                  </td>
                  <td valign="middle" align="center"><tt>Z4</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt>B23</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">m<br>
                  </td>
                  <td valign="middle">Position in target plane
                    coordinates<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">435<br>
                  </td>
                  <td valign="middle" align="center"><tt>EMRR</tt><tt><br>
                    </tt><tt>TLEMR1</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><br>
                  </td>
                  <td valign="middle">Error monitor register
                    contents.&nbsp; Change indicates ladder failure or
                    redundancy disagreement.<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">441<br>
                  </td>
                  <td valign="middle" align="center"><tt>INT</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><br>
                  </td>
                  <td valign="middle">LLS, OBCO, TLC, or S4BCO
                    interrupt.&nbsp; Refer to p. 6.</td>
                </tr>
                <tr>
                  <td valign="middle" align="center">444<br>
                  </td>
                  <td valign="middle" align="center"><tt>X4</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt>B23</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">m<br>
                  </td>
                  <td valign="middle">Position in target plane
                    coordinates</td>
                </tr>
                <tr>
                  <td valign="middle" align="center">450<br>
                  </td>
                  <td valign="middle" align="center"><tt>Y4</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt>B23</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">m<br>
                  </td>
                  <td valign="middle">Position in target plane
                    coordinates</td>
                </tr>
                <tr>
                  <td valign="middle" align="center">460<br>
                  </td>
                  <td valign="middle" align="center"><tt>T3I</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt>B10</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">sec<br>
                  </td>
                  <td valign="middle">Time-to-go in S4B second burn<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">461<br>
                  </td>
                  <td valign="middle" align="center"><tt>TLCHPC</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><br>
                  </td>
                  <td valign="middle">TLC ("tough luck charlie") HOP
                    constant<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">465<br>
                  </td>
                  <td valign="middle" align="center"><tt>DIS.IN</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><br>
                  </td>
                  <td valign="middle">Discrete inputs.&nbsp; Refer to p.
                    6.</td>
                </tr>
                <tr>
                  <td valign="middle" align="center">471<br>
                  </td>
                  <td valign="middle" align="center"><tt>SQ3</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt>B1</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><br>
                  </td>
                  <td valign="middle">(1-ZSP<sup>2</sup>)<sup>1/2</sup></td>
                </tr>
                <tr>
                  <td valign="middle" align="center">475<br>
                  </td>
                  <td valign="middle" align="center"><tt>TBBU</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><br>
                  </td>
                  <td valign="middle">Time base backup<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">500<br>
                  </td>
                  <td valign="middle" align="center"><tt>FDBK</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><br>
                  </td>
                  <td valign="middle">Switch-selector feedback register,
                    in the event of an error<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">501<br>
                  </td>
                  <td valign="middle" align="center"><tt>MLCHIZ</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt>B0</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">pirad<br>
                  </td>
                  <td valign="middle">Minor loop CHIZ<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">504<br>
                  </td>
                  <td valign="middle" align="center"><tt>ZDDV</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt>B4</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">m/sec<sup>2</sup></td>
                  <td valign="middle">Component of vent acceleration<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">505<br>
                  </td>
                  <td valign="middle" align="center"><tt>MLCHIX</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt>B0</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">pirad<br>
                  </td>
                  <td valign="middle">Minor loop CHIX</td>
                </tr>
                <tr>
                  <td valign="middle" align="center">510<br>
                  </td>
                  <td valign="middle" align="center"><tt>XDDV</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt>B4</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">m/sec<sup>2</sup></td>
                  <td valign="middle">Component of vent acceleration<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">511<br>
                  </td>
                  <td valign="middle" align="center"><tt>MLCHIY</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt>B0</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">pirad<br>
                  </td>
                  <td valign="middle">Minor loop CHIY</td>
                </tr>
                <tr>
                  <td valign="middle" align="center">514<br>
                  </td>
                  <td valign="middle" align="center"><tt>YDDV</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt>B4</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">m/sec<sup>2</sup></td>
                  <td valign="middle">Component of vent acceleration<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">520<br>
                  </td>
                  <td valign="middle" align="center"><tt>ZDDD</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt>B4</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">m/sec<sup>2</sup></td>
                  <td valign="middle">Component of drag acceleration</td>
                </tr>
                <tr>
                  <td valign="middle" align="center">524<br>
                  </td>
                  <td valign="middle" align="center"><tt>XDDD</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt>B4</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">m/sec<sup>2</sup></td>
                  <td valign="middle">Component of drag acceleration</td>
                </tr>
                <tr>
                  <td valign="middle" align="center">530<br>
                  </td>
                  <td valign="middle" align="center"><tt>YDDD</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt>B4</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">m/sec<sup>2</sup></td>
                  <td valign="middle">Component of drag acceleration</td>
                </tr>
                <tr>
                  <td valign="middle" align="center">534<br>
                  </td>
                  <td valign="middle" align="center"><tt>ALT</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt>B4</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">m<br>
                  </td>
                  <td valign="middle">Altitude<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">535<br>
                  </td>
                  <td valign="middle" align="center"><tt>TLEMR8</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><br>
                  </td>
                  <td valign="middle">Minor-loop error code<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">544<br>
                  </td>
                  <td valign="middle" align="center"><tt>TAUD</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt>B10</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">sec<br>
                  </td>
                  <td valign="middle">Time-to-go<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">561<br>
                  </td>
                  <td valign="middle" align="center"><tt>TI</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt>B15</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center">sec<br>
                  </td>
                  <td valign="middle">Time from GRR of time-base change<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">570<br>
                  </td>
                  <td valign="middle" align="center">(various)<br>
                  </td>
                  <td valign="middle" align="center"><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><br>
                  </td>
                  <td valign="middle">Minor-loop error code.&nbsp; Refer
                    to pp. 6 and 14.<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">571<br>
                  </td>
                  <td valign="middle" align="center"><tt>ETC</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><br>
                  </td>
                  <td valign="middle">End of telemetry cycle, one per
                    computation cycle<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">575<br>
                  </td>
                  <td valign="middle" align="center"><tt>BTC</tt><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><tt><br>
                    </tt></td>
                  <td valign="middle" align="center"><br>
                  </td>
                  <td valign="middle">Begin telemetry cycle, one per
                    computation cycle<br>
                  </td>
                </tr>
              </tbody>
            </table>
            <br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">0<br>
          </td>
          <td valign="middle" align="center">1<br>
          </td>
          <td valign="middle" align="center"><i>A</i></td>
          <td valign="middle" align="center"><i>A</i></td>
          <td valign="middle" align="center"><i>A</i></td>
          <td valign="middle" align="center"><i>A</i></td>
          <td valign="middle" align="center"><i>A</i></td>
          <td valign="middle" align="center">0<br>
          </td>
          <td valign="middle" align="center"><i>A</i><br>
          </td>
          <td valign="middle">LVDC Main Memory<br>
          </td>
          <td valign="middle">LVDA Telemetry Registers<span
              style="font-style: italic;"></span></td>
        </tr>
        <tr>
          <td valign="middle" align="center">1<br>
          </td>
          <td valign="middle" align="center">1<br>
          </td>
          <td valign="middle" align="center"><i>A</i></td>
          <td valign="middle" align="center"><i>A</i></td>
          <td valign="middle" align="center"><i>A</i></td>
          <td valign="middle" align="center"><i>A</i></td>
          <td valign="middle" align="center"><i>A</i></td>
          <td valign="middle" align="center">0<br>
          </td>
          <td valign="middle" align="center"><i>A</i><br>
          </td>
          <td valign="middle">LVDC Residual Memory<br>
          </td>
          <td valign="middle">LVDA Telemetry Registers<span
              style="font-style: italic;"></span></td>
        </tr>
        <tr>
          <td valign="middle" align="center">X<br>
          </td>
          <td valign="middle" align="center">0<br>
          </td>
          <td valign="middle" align="center"><i>A</i><i><br>
            </i></td>
          <td valign="middle" align="center"><i>A</i><i><br>
            </i></td>
          <td valign="middle" align="center"><i>A</i><i><br>
            </i></td>
          <td valign="middle" align="center"><i>A</i><i><br>
            </i></td>
          <td valign="middle" align="center"><i>A</i><i><br>
            </i></td>
          <td valign="middle" align="center">1<br>
          </td>
          <td valign="middle" align="center">0<br>
          </td>
          <td valign="middle">LVDC Accumulator Register</td>
          <td valign="middle">LVDA Output Registers<br>
          </td>
          <td colspan="1" rowspan="3" valign="middle">
            <table width="80%" cellspacing="2" cellpadding="2"
              border="1" align="center">
              <tbody>
                <tr>
                  <th valign="top">A7 - A1 (octal) </th>
                  <th valign="top" align="left">Purpose<br>
                  </th>
                </tr>
                <tr>
                  <td valign="top" align="center">006<br>
                  </td>
                  <td valign="top">Mode Register<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">012 </td>
                  <td valign="top">Discrete Output Register
                    (Reset).&nbsp; The <a
                      href="Documents/satinstunitibm_3.pdf">LVDC EDD for
                      the Saturn IB Flight Program</a> document, section
                    7.3, summarizes the discrete outputs as: <br>
                    <div align="center"><img alt="" src="lvdcDO.png"
                        width="497" height="285"><br>
                    </div>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">016 </td>
                  <td valign="top">Discrete Output Register (Set).&nbsp;
                    See <tt>PIO 012</tt> above.<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">022 </td>
                  <td valign="top">Internal Control Register (Set)<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">026 </td>
                  <td valign="top">Internal Control Register (Reset)<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">032 </td>
                  <td valign="top">Interrupt Register Reset<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">036 </td>
                  <td valign="top">Switch Selector Register (Load)<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">042 </td>
                  <td valign="top">Orbital Checkout<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">052 </td>
                  <td valign="top">Switch Selector &amp; Discrete Output
                    Registers (Read)<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">062 </td>
                  <td valign="top">Switch Selector Interrupt Counter<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">066 </td>
                  <td valign="top">COD Error (Read)<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">072 </td>
                  <td valign="top">Inhibit Interrupt<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">076 </td>
                  <td valign="top">Minor Loop Timed Interrupt Counter<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">146 </td>
                  <td valign="top">Ladder No. 1<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">152 </td>
                  <td valign="top">Ladder No. 2<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">156 </td>
                  <td valign="top">Ladder No. 3<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">162 </td>
                  <td valign="top">Ladder No. 4<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">166 </td>
                  <td valign="top">Ladder No. 5<br>
                  </td>
                </tr>
              </tbody>
            </table>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">0<br>
          </td>
          <td valign="middle" align="center">1<br>
          </td>
          <td valign="middle" align="center"><i>A</i><i><br>
            </i></td>
          <td valign="middle" align="center"><i>A</i><i><br>
            </i></td>
          <td valign="middle" align="center"><i>A</i><i><br>
            </i></td>
          <td valign="middle" align="center"><i>A</i><i><br>
            </i></td>
          <td valign="middle" align="center"><i>A</i><i><br>
            </i></td>
          <td valign="middle" align="center">1<br>
          </td>
          <td valign="middle" align="center">0<br>
          </td>
          <td valign="middle">LVDC Main Memory</td>
          <td valign="middle">LVDA Output Registers</td>
        </tr>
        <tr>
          <td valign="middle" align="center">1<br>
          </td>
          <td valign="middle" align="center">1<br>
          </td>
          <td valign="middle" align="center"><i>A</i><i><br>
            </i></td>
          <td valign="middle" align="center"><i>A</i><i><br>
            </i></td>
          <td valign="middle" align="center"><i>A</i><i><br>
            </i></td>
          <td valign="middle" align="center"><i>A</i><i><br>
            </i></td>
          <td valign="middle" align="center"><i>A</i><i><br>
            </i></td>
          <td valign="middle" align="center">1<br>
          </td>
          <td valign="middle" align="center">0<br>
          </td>
          <td valign="middle">LVDC Residual Memory</td>
          <td valign="middle">LVDA Output Registers</td>
        </tr>
        <tr>
          <td valign="middle" align="center">X<br>
          </td>
          <td valign="middle" align="center">0<br>
          </td>
          <td valign="middle" align="center"><i>A</i><i><br>
            </i></td>
          <td valign="middle" align="center"><i>A</i><i><br>
            </i></td>
          <td valign="middle" align="center"><i>A</i><i><br>
            </i></td>
          <td valign="middle" align="center"><i>A</i><i><br>
            </i></td>
          <td valign="middle" align="center"><i>A</i><i><br>
            </i></td>
          <td valign="middle" align="center">1<br>
          </td>
          <td valign="middle" align="center">1<br>
          </td>
          <td valign="middle">LVDA Peripheral Inputs and Errors<br>
          </td>
          <td valign="middle">LVDC Accumulator<br>
          </td>
          <td valign="middle">
            <table width="80%" cellspacing="2" cellpadding="2"
              border="1" align="center">
              <tbody>
                <tr>
                  <th valign="top">A8 - A1 (octal) </th>
                  <th valign="top" align="left">Purpose<br>
                  </th>
                </tr>
                <tr>
                  <td valign="top" align="center">023<br>
                  </td>
                  <td valign="top">Error Monitor Register<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">043<br>
                  </td>
                  <td valign="top">Command Receiver or RCA-110<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">053<br>
                  </td>
                  <td valign="top">Discrete Input Spares.&nbsp; Refer to
                    the DIS1-DIS8 inputs in the table for <tt>PIO 057</tt>
                    below.<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">057<br>
                  </td>
                  <td valign="top">Discrete Inputs.&nbsp; The <a
                      href="Documents/satinstunitibm_3.pdf">LVDC EDD for
                      the Saturn IB Flight Program</a> document, section
                    7.4, summarizes the discrete inputs in the table
                    below.&nbsp; (The DIS1-DIS8 inputs in the table for
                    <tt>PIO 053</tt> above.)<br>
                    <div align="center"><img alt="" src="lvdcDI.png"
                        width="499" height="549"><br>
                      <div align="left">The Command Decoder OM/D bits
                        mentioned in the table originate in an <a
                          href="#Up-data">up-data command word</a>
                        transmitted to the rocket from mission
                        control.&nbsp; There are two such bits in the
                        transmitted word, but the LVDA combines them
                        into a single bit before passing them to the
                        LVDC — hence, OM/D bits "A" and "B" both appear
                        at the same position in <tt>PIO 057</tt>.&nbsp;
                        A value of 1 in the OM/D bit indicates that a
                        "mode" command word has been received (and is
                        accessible via <tt>PIO 043</tt>), while a value
                        of 0 indicates instead that a "data" command
                        word has been received (in <tt>PIO 043</tt>).<br>
                      </div>
                    </div>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">067<br>
                  </td>
                  <td valign="top">Telemetry Scanner<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">077<br>
                  </td>
                  <td valign="top">Switch Selector<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">103<br>
                  </td>
                  <td valign="top">Real Time<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">107<br>
                  </td>
                  <td valign="top">Accelerometer Processor X<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">117<br>
                  </td>
                  <td valign="top">Accelerometer Processor Z<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">127<br>
                  </td>
                  <td valign="top">Accelerometer Processor Y </td>
                </tr>
                <tr>
                  <td valign="top" align="center">137<br>
                  </td>
                  <td valign="top">Interrupt Storage </td>
                </tr>
              </tbody>
            </table>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">X<br>
          </td>
          <td valign="middle" align="center">1<br>
          </td>
          <td valign="middle" align="center"><i>A</i><i><br>
            </i></td>
          <td valign="middle" align="center"><i>A</i><i><br>
            </i></td>
          <td valign="middle" align="center"><i>A</i><i><br>
            </i></td>
          <td valign="middle" align="center"><i>A</i><i><br>
            </i></td>
          <td valign="middle" align="center"><i>A</i><i><br>
            </i></td>
          <td valign="middle" align="center">1<br>
          </td>
          <td valign="middle" align="center">1<br>
          </td>
          <td valign="middle">LVDA Resolver Processor Inputs<br>
          </td>
          <td valign="middle">LVDC Accumulator</td>
          <td valign="middle">
            <table width="80%" cellspacing="2" cellpadding="2"
              border="1" align="center">
              <tbody>
                <tr>
                  <th valign="top">A7 - A1 (octal) </th>
                  <th valign="top" align="left">Purpose<br>
                  </th>
                </tr>
                <tr>
                  <td valign="middle" align="center">203<br>
                  </td>
                  <td valign="top">Z Gimbal Backup.&nbsp; (This is not
                    covered by the available documentation, but seems to
                    be implied by the comments in the source code.)<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">207<br>
                  </td>
                  <td valign="top">Spare No. 6<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">217<br>
                  </td>
                  <td valign="top">Computer COD Counter Start<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">223<br>
                  </td>
                  <td valign="top">Fine Gimbal No. 1<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">233<br>
                  </td>
                  <td valign="top">Coarse Gimbal No. 3<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">237<br>
                  </td>
                  <td valign="top">Computer COD Counter Start<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">243<br>
                  </td>
                  <td valign="top">Coarse Gimbal No. 1<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">247<br>
                  </td>
                  <td valign="top">Horizon Seeker No. 1<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">257<br>
                  </td>
                  <td valign="top">Spare No. 3<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">277<br>
                  </td>
                  <td valign="top">Spare No. 4<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">313<br>
                  </td>
                  <td valign="top">Fine Gimbal No. 4<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">317<br>
                  </td>
                  <td valign="top">Spare No. 1<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">323<br>
                  </td>
                  <td valign="top">Horizon Seeker No. 3<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">327<br>
                  </td>
                  <td valign="top">Horizon Seeker No. 2<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">333<br>
                  </td>
                  <td valign="top">Coarse Gimbal No. 4<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">337<br>
                  </td>
                  <td valign="top">Spare No. 5<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">343<br>
                  </td>
                  <td valign="top">Coarse Gimbal No. 2<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">353<br>
                  </td>
                  <td valign="top">Fine Gimbal No. 3<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">357<br>
                  </td>
                  <td valign="top">Spare No. 2<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">363<br>
                  </td>
                  <td valign="top">Fine Gimbal No. 2<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">367<br>
                  </td>
                  <td valign="top">Horizon Seeker No. 4<br>
                  </td>
                </tr>
              </tbody>
            </table>
          </td>
        </tr>
      </tbody>
    </table>
    <h3><a name="Subroutine_Linkage" id="Subroutine_Linkage"></a>Subroutine












































































      Linkage</h3>
    While the LVDC is executing an instruction, it is also forming the
    HOP constant of the next instruction in sequence—i.e., on the
    assumption that no branch occurs—and this HOP constant is available
    to the next instruction that executes.&nbsp; In most cases, this
    means that an instruction can find out its own address (which isn't
    very interesting), but if the previous instruction was a branch then
    it means that the current instruction can determine the address of
    the instruction in sequence that followed the branch instruction,
    and thus can use this information for setting up returns from
    subroutines.&nbsp; The instruction for fetching that HOP constant
    and saving it is either <span style="font-family: courier
      new,courier,monospace;">STO 0776</span> or <span
      style="font-family: courier new,courier,monospace;">STO 0777</span>.&nbsp;
Only












































































    those special addresses work.&nbsp; So a typical subroutine linkage
    would look like this:<br>
    <br>
    <div style="margin-left: 80px;"> <span style="font-family: courier
        new,courier,monospace;">&nbsp;&nbsp;&nbsp;
        TRA&nbsp;&nbsp;&nbsp;&nbsp; MYSUB<br>
      </span> </div>
    <div style="margin-left: 40px;"> <span style="font-family: courier
        new,courier,monospace;">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; ... <i>return




















          to here</i> ...<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>
        <br>
        MYSUB&nbsp;&nbsp; STO&nbsp;&nbsp;&nbsp;&nbsp;
        0776&nbsp;&nbsp;&nbsp; # or, STO 0777<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... <i>do stuff</i>
        ...<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        HOP&nbsp;&nbsp;&nbsp;&nbsp; 0776&nbsp;&nbsp;&nbsp; # or, HOP
        0777<br>
      </span> </div>
    <br>
    <h3><a name="Interrupts" id="Interrupts"></a>Interrupts</h3>
    There are up to 12 external interrupt sources, buffered by the
    LVDA.&nbsp; Upon any of these becoming active, the LVDA generates a
    master interrupt signal to the LVDC.&nbsp; When the LVDC receives
    the master interrupt signal, assuming that interrupts have not been
    programmatically inhibited, the following actions occur:<br>
    <ol>
      <li>The LVDC automatically masks that particular interrupt from
        occurring again until explicitly reenabled (at step 9 below).<br>
      </li>
      <li>The LVDC allows any instruction, multiplication, or division
        in progress to complete.</li>
      <li>The LVDC performs a <span style="font-family: Courier
          New,Courier,monospace;">HOP 0400</span>, thus transferring
        control to an interrupt-service routine—or, as the original
        documents refer to it, an "input-output subprogram".&nbsp;
        Recall that this does not jump to address 0400, rather it loads
        the HOP Register from the value stored at address 0400, and this
        can be used to jump to a location, set the current memory module
        and sector, etc.&nbsp; (Early non-flight hardware seemingly used
        a <span style="font-family: Courier New,Courier,monospace;">HOP
          0776</span> instead of <span style="font-family: Courier
          New,Courier,monospace;">HOP 0400</span>.)<br>
      </li>
      <li>The <span style="font-style: italic;">first</span>
        instruction executed by the interrupt service routine must be
        either <span style="font-family: Courier
          New,Courier,monospace;">STO 0776</span> or <span
          style="font-family: Courier New,Courier,monospace;">STO 0777</span>
        to store the pre-interrupt value of the HOP Register at either
        address 0776 or 0777.</li>
      <li>The interrupt service routine should then save any registers
        or common memory locations that were going to be altered into
        local storage.&nbsp; In almost all cases, one would suppose that
        the accumulator needed to be stored.&nbsp; If multiplications or
        divisions would be used, the P-Q Register would also need to be
        saved, presumably with a pair of instructions like <span
          style="font-family: Courier New,Courier,monospace;">CLA 0775</span>
        followed by <span style="font-family: Courier
          New,Courier,monospace;">STO <span style="font-style: italic;">somewhere</span></span>.</li>
      <li>The interrupt service routine should do a <span
          style="font-family: Courier New,Courier,monospace;">PIO</span>
        from the Interrupt Storage input port to determine which of the
        12 interrupt sources are active, so that it can vector to an
        appropriate service routine for it.<br>
      </li>
      <li>The interrupt service routine should then do whatever
        computations it needed to do.</li>
      <li>The interrupt service routine should restore the registers it
        had saved (<span style="font-family: Courier
          New,Courier,monospace;">CLA <span style="font-style: italic;">somewhere</span></span>
        followed by <span style="font-family: Courier
          New,Courier,monospace;">STO 0775</span> to restore the P-Q
        Register, if necessary, followed by a restoration of the
        accumulator).</li>
      <li>The interrupt service routine should do a <span
          style="font-family: Courier New,Courier,monospace;">PIO</span>
        to the Interrupt Register Reset output port, with just the
        specific bit set corresponding to the interrupt type being
        processed, to reenable that specific interrupt.&nbsp; The
        particular flavor of <span style="font-family: Courier
          New,Courier,monospace;">PIO</span> performed should, of
        course, take the Data Source from memory rather than from the
        accumulator, since at this point the accumulator has already
        been restored to its pre-interrupt condition.<br>
      </li>
      <li>The return from interrupt is either <span style="font-family:
          Courier New,Courier,monospace;">HOP 0776</span> or <span
          style="font-family: Courier New,Courier,monospace;">HOP 0777</span>,
        depending on which location the HOP constant had been stored on
        entry to the interrupt service routine.</li>
    </ol>
    Interrupts can be programmatically masked or unmasked with <span
      style="font-family: Courier New,Courier,monospace;">PIO</span> to
    Interrupt Inhibit.&nbsp; By setting a bit in Interrupt Inhibit
    corresponding to the interrupt whose masking is desired, that
    interrupt is thereby masked.&nbsp; Any combination of bits can be
    set, so any combination of interrupts can be masked.&nbsp; To
    reenable the interrupt, a 0 is written to the corresponding bit in
    Interrupt Inhibit.<br>
    <br>
    The available interrupts, and their bitwise positioning in the i/o
    registers mentioned above, differed for the Saturn IB rocket (Apollo
    7, ASTP, Skylab) vs. the Saturn V rocket (Apollo 8-17).&nbsp; The
    Saturn IB and Saturn V descriptions below were taken from different
    documents (namely, <a
      href="Documents/MSFC-MAN-206-SkylabSaturnIBFlightManual.pdf"> <span
        style="font-style: italic;">Skylab Saturn IB Flight Manual</span></a>
    p. 6-21 and <a style="font-style: italic;"
      href="Documents/MSFC-MAN-503-SaturnFlightManual-SA503.pdf"> Saturn
      Flight Manual, SA-503</a> p. 7-21, respectively), and if one
    accounts for the differences in language between the two documents,
    the interrupts are almost entirely the same. I've marked the ones in
    <span style="color: rgb(255, 0, 0);">red</span> that seem different
    to me, as well as any other points of particular difficulty for me.<br>
    <br>
    <table summary="" style="text-align: left; margin-left: auto;
      margin-right: auto;" cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <th style="font-weight: bold; text-align: center;">LVDC Data
            Word Bit Position<br>
          </th>
          <th style="font-weight: bold;">Description of function in
            Saturn IB<br>
          </th>
          <th style="font-weight: bold;">Description of function in
            Saturn V<br>
          </th>
          <th style="vertical-align: middle;">Are these actually the
            same thing?<br>
          </th>
          <th>Comments<br>
          </th>
        </tr>
        <tr>
          <td style="text-align: center;">11<br>
          </td>
          <td>RCA-110A interrupt<br>
          </td>
          <td>Command LVDA/RCA-110A interrupt<br>
          </td>
          <td>Probably.<br>
          </td>
          <td>The RCA-110A is the ground-control computer.&nbsp; This
            interrupt implies that a command word has been received via
            digital uplink and is ready to be processed.&nbsp; See
            section 6.2.3 of <a style="font-style: italic;"
href="Documents/MSFC-IV-4-401-1-AstrionicsSystemHandbookSaturnLaunchVehicles.pdf">Astrionic












































































              System Handbook, Saturn Launch Vehicles</a>.</td>
        </tr>
        <tr>
          <td style="text-align: center;">10<br>
          </td>
          <td>S-IB low-level sensors dry "A"<br>
          </td>
          <td>S-IC inboard engine out "A"<br>
          </td>
          <td>If interpreted as "first stage engine out", yes.</td>
          <td><br>
          </td>
        </tr>
        <tr>
          <td style="text-align: center;">9<br>
          </td>
          <td>RCA-110A interrupt<br>
          </td>
          <td>Program re-cycle (RCA-110A) interrupt<br>
          </td>
          <td>Probably.<br>
          </td>
          <td>The RCA-110A is the ground-control computer.&nbsp; The
            following is partly speculation, so take it with a grain of
            salt: I believe that this interrupt may occur when a special
            uplink command ("Terminate") is received.&nbsp; The purpose
            of the "Terminate" command is to halt an operation from a
            previously uplinked command (see above) and to return the
            LVDC flight program to normal operation.&nbsp; Since the
            "command LVDA/RCA-110A" interrupt would be disabled until
            that processing is completed, a separate interrupt for the
            "Terminate" command is needed, and that is the "Program
            re-cycle" interrupt.<br>
          </td>
        </tr>
        <tr>
          <td style="text-align: center;">8<br>
          </td>
          <td>S-IVB engine out "B"<br>
          </td>
          <td>S-IVB engine out "B"<br>
          </td>
          <td>Yes.<br>
          </td>
          <td><br>
          </td>
        </tr>
        <tr>
          <td style="text-align: center;">7<br>
          </td>
          <td>S-IB outboard engines cutoff "A"<br>
          </td>
          <td>S-IC propellant depletion/engine cutoff "A"<br>
          </td>
          <td>If interpreted as "first stage engine cutoff", yes.</td>
          <td><br>
          </td>
        </tr>
        <tr>
          <td style="text-align: center;">6<br>
          </td>
          <td>Manual initiation of S-IVB engine cutoff "A"<br>
          </td>
          <td>S-II propellant depletion/engine cutoff<br>
          </td>
          <td style="color: rgb(255, 0, 0);">Both refer to the second
            stage, but ... don't know!<br>
          </td>
          <td><br>
          </td>
        </tr>
        <tr>
          <td style="text-align: center;">5<br>
          </td>
          <td>Guidance reference release<br>
          </td>
          <td>Guidance reference release<br>
          </td>
          <td>Yes.<br>
          </td>
          <td><br>
          </td>
        </tr>
        <tr>
          <td style="text-align: center;">4<br>
          </td>
          <td>Command decoder interrupt "A" or "B"<br>
          </td>
          <td>Command receiver interrupt<br>
          </td>
          <td>Probably.<br>
          </td>
          <td><span style="color: rgb(255, 0, 0);">I think this
              interrupt comes from the decoder that interprets uplinked
              data (see the two RCA-110A interrupts above), but it's
              unclear to me what the purpose is, or how "A" and "B"
              differ.</span><br>
          </td>
        </tr>
        <tr>
          <td style="text-align: center;">3<br>
          </td>
          <td>Simultaneous memory error<br>
          </td>
          <td>Temporary loss of control<br>
          </td>
          <td>Yes.<br>
          </td>
          <td>"Simultaneous memory error" refers to simultaneous parity
            errors in a single address mirrored in duplexed memory
            modules.&nbsp; This is also known by the acronym TLC, which
            is related in an obvious way to the description "Temporary
            Loss of Control" supplied by the documentation.&nbsp;
            However, "temporary loss of control" is quite an optimistic
            way of looking at it, because there is no method of recovery
            from it.&nbsp; Far from being "temporary", the error is
            basically immediately catastrophic in the real world of the
            rocket, and therefore very permanent.&nbsp; I have been told
            that the LVDC programmers called this the "Tough Luck
            Charlie" interrupt, and indeed there is a reference to this
            in the LVDC source code.<br>
          </td>
        </tr>
        <tr>
          <td style="text-align: center;">2<br>
          </td>
          <td>Spare<br>
          </td>
          <td>Computer interface unit interrupt<br>
          </td>
          <td style="color: rgb(255, 0, 0);">No.<br>
          </td>
          <td><br>
          </td>
        </tr>
        <tr>
          <td style="text-align: center;">1<br>
          </td>
          <td>Internal to the LVDC<br>
          </td>
          <td>Switch selector interrupt<br>
          </td>
          <td rowspan="2">Probably.<br>
          </td>
          <td rowspan="2">The switch-selector interrupt and the
            minor-loop interrupt are generated internally by the
            LVDC/LVDA.<br>
          </td>
        </tr>
        <tr>
          <td style="text-align: center;">S<br>
          </td>
          <td>Internal to the LVDC<br>
          </td>
          <td>Minor loop interrupt<br>
          </td>
        </tr>
      </tbody>
    </table>
    <h3><a name="Telemetry" id="Telemetry"></a>Telemetry</h3>
    Output telemetry from the Instrumentation Unit transmitted to
    mission control can be sourced from either the LVDC or the
    LVDA.&nbsp; The LVDA spontaneously outputs telemetry on its own
    accord only when an error indication appears in its error-monitor
    register.&nbsp; The normal telemetry case, however, is that the LVDC
    initiates output telemetry by sending data to the LVDA via a <tt>PIO</tt>
    CPU instruction, and then the LVDA handles subsequent details of
    actually transmitting the data.&nbsp; In both cases, the output is
    in the form of 10-bit arrays, though the output packet logically
    consists of 4 such successive 10-bit arrays: i.e., of 40 bits.&nbsp;
    <br>
    <br>
    However, the specifics differ depend somewhat on the source.&nbsp;
    We'll confine our description to data sourced by the LVDC.&nbsp; As
    mentioned above, telemetering an output 40-bit packet from the
    LVDC's perspective is done by means of the CPU's <tt>PIO</tt>
    instruction, for which <a
      href="LVDC.html#IO_Ports_For_PIO_Instruction">a variety of i/o
      addresses are reserved for telemetry operations</a>.&nbsp; Of the
    40 bits:<br>
    <ul>
      <li>26 bits are the data payload.&nbsp; These bits come directly
        from the operand of the <tt>PIO</tt> instruction.</li>
      <li>9 bits are a tag indicating the specify type of data in the
        packet.</li>
      <ul>
        <li>Bit A9: TBD</li>
        <li>Bit A8: 1.&nbsp; (1 for telemetry requested by the LVDC, and
          0 for the LVDA.)</li>
        <li>Bits A7-A1.&nbsp; These apparently come from the i/o address
          in the <tt>PIO</tt> instruction.&nbsp;&nbsp; For example, the
          instructions <tt>CLA =67 / PIO 040</tt> would end up setting
          A7-A1 of the tag to 040 (octal), while the data payload would
          be set to 67 (decimal).<br>
        </li>
      </ul>
      <li>3 bits determine the "mode".&nbsp; I'm not sure where these
        bits come from, but perhaps they come from the mode register,
        which the LVDC software sets via <tt>PIO 006</tt>.<br>
      </li>
      <li>1 bit indicates validity of the packet.&nbsp; The value of the
        bit is 0 if valid and 1 if invalid, and is present because the
        LVDC <tt>PIO</tt> operation can clobber an output already in
        progress, due to lack of synchronization between the LVDC and
        LVDA.&nbsp; At any rate, this bit is manipulated by the LVDA,
        and is transparent to the LVDC.<br>
      </li>
      <li>1 bit is parity.&nbsp; The overall parity of the 40-bit packet
        is odd.&nbsp; The parity bit is generated by the LVDA, and is
        transparent to the LVDC.</li>
    </ul>
    Different documentation differs in describing the arrangement of
    these various bits within the 40-bit packet, and does not fully
    explain the transmission order of the bits, so I'll refrain from
    discussing that topic here.<br>
    <br>
    A 40-bit packet requires 4.17 milliseconds to transmit, and thus the
    LVDC needs to space out its telemetry requests by at least this
    amount of time, or else subsequent telemetry request it outputs to
    the LVDA will overwrite and destroy prior requests.<br>
    <br>
    As far as the numerical specifics of the tag values used in the
    40-bit packets, this is TBD.<br>
    <h3><a name="Up-data"></a>Up-data</h3>
    <p>(A lot of information in this section is abstracted from the <a
        href="Documents/AstrionicsSystemsHandbook_Nov69.pdf">Astrionics
        System Handbook</a>, chapter 6, "Radio Command Systems".)<br>
    </p>
    <p>The term <i>up-data</i> refers to commands transmitted from
      mission control to the LVDC/LVDA.<br>
    </p>
    <p>As transmitted, the standard command-word format consists of 35
      bits:<br>
    </p>
    <ul>
      <li>3 bits are referred to as the "X" bits.&nbsp; They form an
        address, indicating which vehicle the message is intended for. <br>
      </li>
      <li>14 bits are also an address, but they identify a specific
        "command decoder" for processing the message.&nbsp; A vehicle
        may have multiple command decoders with different hard-coded
        addresses.<br>
      </li>
      <li>18 bits comprise the control and data portions of the message.<br>
      </li>
    </ul>
    <p>The latter two sets of bits are interspersed within the message,
      and thus are not transmitted in the specific order shown above.<br>
    </p>
    <div align="center"><img alt="" src="upDataLVDC.png" width="923"
        height="501"></div>
    <p>However, the as-transmitted format of the data isn't really very
      relevant to how the LVDC and its software relate to the up-data,
      since only a portion of the transmitted bits reach the LVDC
      software — specifically only some of the bits from the final group
      of 18 — and even then they don't always reach the LVDC in the
      exact form they are transmitted.&nbsp; Thus, let's narrow our
      discussion of the up-data to just the LVDC's perspective.&nbsp;
      The 18 control&amp;data bits of the message are further
      categorized as:<br>
    </p>
    2 "OM/D" or&nbsp;<i>orbital mode/data</i> (OM/D) bits.&nbsp; (These
    are depicted in the image above, presumably mistakenly, as <b>D</b>M/D
















    bits.)&nbsp; The LVDA combines this pair of bits (in some manner
    unknown to me), and thus the LVDC receives a single OM/D bit.&nbsp;
    The LVDC recognizes two types of commands, <i>mode commands words</i>
    and <i>data command words</i>, and the type of the command word is
    determined by the OM/D bits. &nbsp; <br>
    <p>Similarly, there are two transmitted "interrupt bits" (see the
      image above).&nbsp; These cause an interrupt to occur in the LVDC,
      which I believe is designated in <a href="#Interrupts">the
        interrupt table given earlier as bit-position 4</a>, Command
      Receiver Interrupt.<br>
    </p>
    <p>Finally, the 14 remaining bits actually represent just 7 bits of
      actual information, since each bit appears both in its normal form
      and in its logically-complemented form for the purpose of
      error-detection. <br>
    </p>
    <p><img alt="" src="commandWordFormat.png" width="363" height="411"
        align="right">Refer to section 6.2 of <a
        href="Documents/AstrionicsSystemsHandbook_Nov69.pdf">the
        Astrionics System Handbook</a> for more detail, but the LVDC
      software accesses the received command using the following general
      steps:<br>
    </p>
    <ul>
      <li>Do unrelated processing until the Command Receiver interrupt
        occurs. </li>
      <li>Interrogate the OM/D bit of <tt>PIO 057</tt> to verify that
        its value is 1.&nbsp; This means that the received word is a
        "mode command word".&nbsp; (The first word of any sequence of
        commands will be a mode command word, followed by some number of
        "data command words".)<br>
      </li>
      <li>Interrogate <tt>PIO 043</tt> to get the value of the mode
        word, and parses it to determine the specific command that has
        been requested.&nbsp; Each command type will imply the number of
        data command words that will be subsequently transmitted and
        processed.&nbsp; For the sake of discussion, let's call that
        number <i>N</i>.<br>
      </li>
      <li>Outputs telemetry (TBD) indicating successful reception of a
        command word.</li>
      <li>For each of the <i>N</i> data command words that are supposed
        to be received for this sequence, do the following:</li>
      <ul>
        <li>Do unrelated processing until the Command Receiver interrupt
          occurs.</li>
        <li>Interrogate the OM/D bit of <tt>PIO 057</tt> to verify that
          its value is 0.&nbsp; I.e., that the received word is a data
          command word.</li>
        <li>Get the received word using <tt>PIO 043</tt>.</li>
        <li>Buffer the received word in memory.</li>
      </ul>
      <li>After all of the <i>N</i> data words are received, perform
        whatever action is appropriate for the now-completely-received
        command.</li>
    </ul>
    <p>The command word read using <tt>PIO 043</tt> has the format
      shown in the illustration to the right.&nbsp; As mentioned above,
      there are 7 actual data bits, but they appear twice each:&nbsp;
      Once "normally", and once inverted.&nbsp; Besides that, there is a
      "sequence bit" which also appears normally (bit 8) and inverted
      (bit 1).&nbsp; This bet helps to make sure the command words have
      been received in an appropriate order.&nbsp; The sequence bit is 0
      for the mode command word, then 1 for the first data command word
      (if any), and then it just toggles between 0 and 1 for each
      subsequent data command word received.&nbsp; When the next mode
      command word is received, the sequence bit goes back to 0 and the
      pattern repeats.<br>
    </p>
    <p><br>
    </p>
    <h3> </h3>
    <h2><a name="LVDC_Assembly_Language" id="LVDC_Assembly_Language"></a>LVDC
Assembly












































































      Language</h2>
    Unfortunately, there is no surviving manual or other reference
    describing the syntax of LVDC assembly language, nor the pseudo-ops
    available in it, nor any source code for the original LVDC
    assembler.&nbsp; <br>
    <br>
    This section is a compilation of my own inferences about those
    things from evaluating the available LVDC source code and from
    writing my own LVDC assembler.&nbsp; The description is intended to
    be authoritative only in the sense that it describes how my own
    assembler (<a href="#yaLVDCASM_the_LVDC_Cross-Assembler">yaASM.py</a>),





















    which does produce an assembled core-rope image identical to that of
    the original assembler, handles the code.&nbsp; However, my
    description shouldn't be taken as authoritative in any larger
    sense.&nbsp; For example, when I say below that the assembler has an
    initial "preprocessor pass" that performs certain processing, I mean
    that yaASM.py has such a pass; I <i>imagine</i> that the original
    assembler did as well, but cannot guarantee it.<br>
    <br>
    You'll probably need to refer to the previous <a
      href="#CPU_Instructions">discussion of the CPU instructions</a>
    from time to time, in order to follow the discussion.<br>
    <h3><a name="Basic_Factoids"></a> Basic Factoids</h3>
    <i>Empty lines</i>:&nbsp; Are ignored by the assembler.<br>
    <br>
    <i>Code comments (original Project Apollo)</i>:&nbsp; Full-line
    comments seem to be prefixed by the character '*' in column 1.&nbsp;
    Anything left over at the end of a line after the beginning of a
    line has been correctly parsed seems to be treated as a comment, and
    doesn't require any '*' prefix.<br>
    <br>
    <i>Code comments (modern Virtual AGC Project)</i>:&nbsp; Comments <i>I've</i>
    added that were not present in the original listing are all
    full-line comments but with a '#' character in column 1.<br>
    <br>
    <i>Character set</i>:&nbsp; Upper-case alphabetic, numeric, and some
    punctuation.&nbsp; This isn't really any great surprise, of course,
    if you reflect that all of the source code was supplied on computer
    punch cards to the IBM/360 mainframe computer which ran the
    assembler program, and that the character sets supported by keypunch
    machines did not include lower-case characters anyway.&nbsp; Douglas
    Jones has written a fun <a
      href="http://homepage.divms.uiowa.edu/%7Ejones/cards/index.html">exploration
































































      of punch cards</a>, if you're interested in that kind of
    thing.&nbsp; (By the way, I've heard anecdotally that the executable
    program which was output by the assembly of the LVDC software was
    punched into a long mylar tape, perhaps 1.5" wide, which was then
    transported by the coders themselves to Marshall Space Flight
    Center, where the mylar tape was put into a tape reader which
    transferred the program into the ferrite-core memory of the LVDC
    itself.&nbsp; This was possible because, as you may recall from
    above, all of the ferrite cores in the LVDC were both readable <i>and</i>
    writable.&nbsp; This contrasts to the AGC, in which the program was
    stored in read-only memory which had to be <i>manufactured</i>
    rather than simply written to.&nbsp; So installing the software in
    the LVDC was a far less painful, less expensive, much quicker
    process than installing software in the AGC.&nbsp; In the case of
    the AS-206RAM program listing, the assembler helpfully reports that
    the punch tape is 432 feet long.)<br>
    <br>
    <i>Symbols</i> (names of variables, constants, subroutines,
    ...):&nbsp; 6 characters or less, alphanumeric, with the leading
    character alphabetic.&nbsp; They may also contain the character ".",
    though not in the leading position.<br>
    <i><br>
      Literal numerical constants</i>:&nbsp; Decimal literals are as you
    might expect from working with AGC code.&nbsp; They are just regular
    decimal numbers, possibly with a suffixed exponent "<tt>E</tt><tt><i>n</i></tt>"
    for powers of 10, or a suffixed "<tt>B<i>n</i></tt>" for binary
    scaling, or both.&nbsp; Suffixed exponents and scales, if both are
    present, can be in either order.<br>
    <br>
    As far as octal literals are concerned, some contexts (such as the <tt>OCT</tt>
    pseudo-op or the <tt>PIO</tt> instruction) specifically require
    them, in which case there's no special syntax to distinguish them
    from decimal numbers, other than the fact that they're not
    associated with the digits '8' or '9', with decimal points, nor with
    exponents.&nbsp; In some usages there is ambiguity, which case the
    octal literal is prefixed by 'O' (upper-case alphabetical character,
    <i>not</i> a zero).<br>
    <br>
    Regarding conversion of literal numerical constants to bit patterns
    actually stored within 26-bit memory words, there seem to be three
    basic patterns:<br>
    <ul>
      <li>Pure octal constants are <i>left</i>-aligned in their memory
        word.&nbsp; In other words, a constant of <i>N</i> octal digits
        would be right-padded by 26-<i>3N</i> bits of 0.<br>
      </li>
      <li>Pure decimal (integer) constants are fully <i>right</i>-aligned.&nbsp;




















        In other words, a decimal integer encoded as <i>N</i> bits
        would be sign-extended on the left by 26-<i>N</i> bits.</li>
      <li>Decimal non-integer constants are treated as being in the
        range -1.0 &lt; <i>constant</i> &lt; 1.0.&nbsp;</li>
    </ul>
    <p><i><a name="AngleUnits"></a>Units of angular measurement</i>:&nbsp;


















      For most internal purposes, the source code typically measures
      angles in a unit called a <i>pirad</i>.&nbsp; I can find no
      reference to any unit by this name outside of the LVDC source
      code, nor does the LVDC source code choose to define it in the
      program comments.&nbsp; However, from the usage, it seems pretty
      clear that<br>
    </p>
    <blockquote>1 pirad = 180° = <font face="Times New Roman, Times,
        serif">π</font> radians<br>
    </blockquote>
    And then there are <i>ladder units</i>.&nbsp; They are undefined,
    of course, but I suspect this is the form required for outputting
    angular commands to external hardware:<br>
    <blockquote>1° = 1/0.06 ladder units<br>
    </blockquote>
    There are also references to angles measured in <i>2016 fine units</i>,
    again undefined.&nbsp; Apparently, the "fine" refers to "fine
    resolvers", and thus is likely the form in which the angular data is
    delivered to the LVDC from the resolvers.&nbsp; At any rate, it
    appears that<br>
    <blockquote>1° = 2016/5.625 fine units<br>
    </blockquote>
    Finally, there are references to <i>backup units</i>, which are
    (you guessed it!) undefined.&nbsp; It appears that<br>
    <blockquote>1° = 2016/180 backup units<br>
    </blockquote>
    <i>Units of time</i>:&nbsp; The source code sometimes refers to a
    unit of time measurement it calls <i>qms</i>, but does not
    define.&nbsp; I suspect this is the unit of measurement in which the
    real-time clock delivers data to the LVDC.&nbsp; Apparently,<br>
    <blockquote>1 ms = 1/0.24609375 qms<br>
      1 ms ≈&nbsp; 4.063492 qms<br>
    </blockquote>
    In other words, "qms" probably stands for "quarter millisecond".<br>
    <blockquote>
      <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    </blockquote>
    <blockquote></blockquote>
    <ul>
    </ul>
    <i>Format of a non-comment line</i>:&nbsp; <br>
    <ul>
      <li>Columns 1-6:&nbsp; Optional symbol, supplying a name for the
        memory location of the current line of code.&nbsp; The original
        coders called these "left-hand symbols".</li>
      <li>Columns 8-15:&nbsp; The name of the CPU instruction,
        pseudo-op, or macro.&nbsp; Notice that this is <i>not</i>
        aligned with what is sometimes thought of as the default
        position of a "tab stop", which would have been at column 9.</li>
      <li>Columns 16-28:&nbsp; The operand. I'll talk more about these
        operands below.<br>
      </li>
      <li>29-75:&nbsp; Comment, possibly blank.&nbsp;&nbsp;</li>
      <li><a name="SequenceNumber"></a>75-80:&nbsp; Sequence number,
        consisting of 6 decimal digits.&nbsp; These sequence numbers
        came directly from the original punch cards.&nbsp; As a
        convention, the sequence numbers are unique, and are in
        increasing order from one line to the next ... almost always,
        the sequence numbers increment by 10 from one line to the
        next.&nbsp; Nevertheless, there are chunks of code having no
        sequence numbers at all.&nbsp; When that happens, the assembler
        simply adds 10 to the last sequence number it saw, and then
        assigns that same number to all subsequent lines until
        encountering a card with an actual sequence number on it.&nbsp;
        (I'm <i>not</i> saying it increments the sequence number by 10
        on every unnumbered line; it increments it just once, and then
        keeps giving line after line the <i>same</i> number.)&nbsp;
        Given that fact, it's pretty obvious that the cards were
        processed in the order they were encountered, rather than being
        rearranged internally to the assembler in sequence-number
        order.&nbsp; I don't believe the original assembler needed to
        use these sequence numbers other than for reference purposes in
        the symbol table (see below).</li>
    </ul>
    <p>By the way, these observations about columnar alignment don't
      relate to the new assembler (yaASM.py), which does not enforce or
      use the columnar alignment in any way, other than to recognize
      that column 1 is special.&nbsp; I don't know if the original
      assembler actually cared about the columnar alignment, or whether
      the alignment I've observed is simply a convention.<br>
    </p>
    <ul>
    </ul>
    <h3><a name="Preprocessor_Pass"></a>Preprocessor Pass</h3>
    <p>The LVDC assembler is a macro assembler, meaning that the
      language it processes has a variety of constructs intended to make
      coding easier and more manageable but which aren't directly
      related to the internal characteristics of the LVDC CPU.&nbsp;
      These constructs are all resolved and removed from the code by a
      dedicated preprocessor pass prior to any assembly of actual LVDC
      instructions or allocation of LVDC memory.&nbsp; The various
      preprocessor constructs that appear in LVDC code are described in
      this section.<br>
    </p>
    <p>The preprocessor itself operates in a single pass, and therefore
      any symbols or macros it uses must have been defined prior in the
      source code to such use.<br>
    </p>
    <i>The </i><i><tt>CALL</tt></i><i> macro</i>:&nbsp; <tt>CALL</tt>
    is a macro hard-coded into the assembler itself.&nbsp; By a "macro",
    I mean that superficially it is used in source code as if it were a
    CPU instruction, but it is not a CPU instruction.&nbsp; Rather, it
    is a shorthand for a sequence of several CPU instructions.&nbsp; A
    single <tt>CALL</tt> is expanded by the preprocessor into the
    appropriate stream of true CPU instructions.&nbsp; When I say it is
    "hard-coded" into the assembler, I mean that the language also
    includes ways for the programmer to define his own custom macros
    within the LVDC program if he wants, but that there are no such
    definitions for the <tt>CALL</tt> macro in the LVDC source code.<br>
    <br>
    It is probably hard-coded in the assembler rather than having a soft
    definition within the source code because there are two distinct
    variations of it.:&nbsp; There are both 2-argument and 2-argument
    variants of the macro.&nbsp; The 2-argument version is used for
    calling a subroutine having a single input argument.&nbsp; The macro
    is invoked by a source-code line of the form<br>
    <blockquote><tt>CALL <i>ARG1</i>,<i>ARG2</i></tt> <br>
    </blockquote>
    which the preprocessor replaces by a pair of actual instructions, <br>
    <blockquote><tt>CLA <i>ARG2</i></tt><br>
      <tt>HOP <i>ARG1<br>
        </i></tt></blockquote>
    All three lines appear in assembly listings, but the <tt>CALL</tt>
    is treated as a comment and the other two have a '+' character
    printed next to them to show that they're there due to the expansion
    of the macro. <br>
    <br>
    The 3-argument version,<br>
    <blockquote><tt>CALL <i>ARG1,ARG2,ARG3</i></tt> <br>
    </blockquote>
    instead expands as<br>
    <blockquote><tt>CLA ARG3<br>
        STO 775<br>
        CLA ARG2<br>
        HOP ARG1<br>
      </tt></blockquote>
    and thus calls a subroutine with two input arguments.<br>
    <br>
    <i>General macro-definition facility</i>:&nbsp; As I said above, the
    macro facility is general-purpose, and custom macros can also be
    defined within the source code.&nbsp; The syntax used for defining a
    macro is as follows:<br>
    <blockquote><tt><i>NAME</i>&nbsp;&nbsp;&nbsp;
        MACRO&nbsp;&nbsp;&nbsp; ARG1,ARG2,...<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ... code using the symbols
        ARG1, ARG2, and so on ...<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ENDMAC<br>
      </tt></blockquote>
    Once defined, <i><tt>NAME</tt></i> can be used to invoke the
    associated macro.<br>
    <br>
    Note that in the <i>definition</i> of the macro, the strings <tt>ARG1</tt>,
    <tt>ARG2</tt>, and so on are literal.&nbsp; You can't <i>define</i>
    a macro with arbitrary arguments names like (say) <tt>x</tt>, <tt>y</tt>,
    and <tt>z</tt>.&nbsp;&nbsp; <br>
    <br>
    As an example, consider the 2-argument the <tt> CALL</tt> macro
    described earlier.&nbsp; It is hard-coded into the assembler, and
    therefore doesn't require a definition in the code, but if it
    weren't hard-coded it could have been giving the following soft
    definition:<br>
    <blockquote><tt>CALL&nbsp;&nbsp;&nbsp; MACRO&nbsp;&nbsp;&nbsp;
        ARG1,ARG2<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; CLA&nbsp;&nbsp;&nbsp;
        &nbsp; ARG2<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
        HOP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARG1<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ENDMAC<br>
      </tt></blockquote>
    <i>Pseudo variables</i>:&nbsp; "Pseudo variables" are named numeric
    constants known only by the preprocessor.&nbsp; Any usages of such
    pseudo variables are replaced by numeric literals by the
    preprocessor, and thus none of them remain in the code by the time
    the actual assembly process begins.&nbsp; This implies that the
    namespace for pseudo variables is distinct from that for left-hand
    symbols in general, so a pseudo variable can have the same name as a
    block of code or a data variable in memory without overlap.<br>
    <br>
    Pseudo variables are <i>defined</i> by the EQU pseudo-op, with a
    syntax like the following:<br>
    <blockquote><tt><i>NAME</i></tt><tt>&nbsp;&nbsp;&nbsp;
        EQU&nbsp;&nbsp;&nbsp; (</tt><tt><i>EXPRESSION</i></tt><tt>)</tt><br>
    </blockquote>
    In the operand here, the parentheses are literal and must always be
    present.&nbsp; <tt><i>EXPRESSION</i></tt> is an arithmetical
    expression involving numeric literals, the operations + - * /,
    parentheses, and other (previously-defined) pseudo variables.&nbsp;
    For example,<br>
    <blockquote><tt>OMEGA&nbsp;&nbsp; EQU&nbsp;&nbsp;&nbsp;
        (.72921141E-4)</tt><tt><br>
      </tt><tt>RWCP&nbsp;&nbsp;&nbsp; EQU&nbsp;&nbsp;&nbsp;
        (OMEGA*6373377*.87993)</tt><br>
    </blockquote>
    In general, parenthesized expressions involving pseudo-variables
    like this can appear anywhere in LVDC source code, and is replaced
    by the preprocessor with the numeric literals.&nbsp; Except for
    appearing as left-hand symbols in <tt>EQU</tt> statements, pseudo
    variables appear <i>only</i> with such parenthesized expressions,
    or in tests for conditional assembly (see below).<br>
    <br>
    In most usages, an <tt>(<i>EXPRESSION</i>)</tt> appearing in an
    assembly language operand can be suffixed with an optional binary
    scaling factor<br>
    <blockquote><tt>(<i>EXPRESSION</i>)B<i>n</i></tt></blockquote>
    The optional scaling factor doesn't really make sense if it were
    used in the <tt>EQU</tt> statements defining the pseudo-variables,
    since the purpose of the scaling factor is really a relationship
    between the logical value of the number and the physically-pragmatic
    pattern of bits stored in memory.&nbsp; Nevertheless, the assembler
    allows any expression to be thusly suffixed by a scaling factor,
    even in the <tt>EQU</tt> statement itself. <br>
    <i></i><i><br>
      Conditional assembly</i>:&nbsp; Code can be conditionally retained
    or discarded by the preprocessor the basis of a test, with the
    syntax<br>
    <blockquote>
      <p><tt>IF&nbsp;&nbsp;&nbsp; <i>PSEUDOVARIABLE</i><i></i>=(<i>EXPRESSION</i>)<br>
          ... code ...<br>
          ENDIF<br>
        </tt></p>
    </blockquote>
    If the value of the specified pseudo variable is equal the evaluated
    expression, then enclosed code is retained by the preprocessor, and
    is thus eventually assembled.&nbsp; If not, then the enclosed code
    is discarded.<br>
    <h3><a name="Assembly_Pass"></a>Assembly Pass</h3>
    <p>(Technically, what I'm calling the "assembly pass" here is really
      implemented in the new assembler, yaASM.py, in two successive
      passes, known the "discovery pass" and the "assembly pass".&nbsp;
      The former associates all program labels and variable names with
      physical addresses, while the latter performs the actual assembly
      using the now-resolved addresses.&nbsp; That detail is totally
      irrelevant and transparent to the user, but would be necessary
      information to anybody modifying yaASM.py itself.)<br>
    </p>
    <i></i>
    <p><i>Instruction operands</i>:&nbsp; Operand formats differ for
      some CPU instruction types, but most of them require a variable (a
      word in data memory), and conform to a pattern in which there are
      several allowed variants for specifying the operand:<br>
    </p>
    <ol>
      <li>A literal 3-digit octal number (such as 777 or 776), which is
        an offset into the DM/DS (Data Module / Data Sector) defined by
        the current contents of the HOP register.<br>
      </li>
      <li>The symbolic name of a variable or constant defined elsewhere
        in the program.&nbsp; The variable/constant has to be in the
        current DM/DS, so if the referenced symbol doesn't happen to be
        located in that particular module or sector, it could be a
        problem.</li>
      <li>An arithmetical expression involving symbolic names, such as <tt>CBTAB+1</tt>
        or <tt>CBTAB+(4*CBSTNO+1)</tt>.&nbsp; For a sufficiently
        complex expression, since as the latter one in the preceding
        sentence, the raw form of the instruction will appear in the
        assembly listing as if it were a comment (like a <tt>CALL</tt>
        line), and the fully resolved expression will appear marked with
        a "+" character as if it were a macro expansion ... which it
        probably is.&nbsp; For example, if <tt>(4*CBSTNO+1)</tt>
        resolves to 57, then the expanded instruction would be <tt>CBTAB+57</tt>.&nbsp;













































        Note that such expressions, depending on what they contain, may
        resolve <i>either</i> to an address in memory, or else to a
        constant value.&nbsp; In the latter case, the numerical constant
        is treated like the constants described in the following item.<br>
      </li>
      <li>The character <tt>=</tt>, prefixed to a literal numerical
        constant.&nbsp; Here the assembler allocates an <i>unnamed</i>
        variable in the current DM/DS, stores the value of the constant
        at that variable, and then uses the location of the new-created
        variable as the operand.&nbsp; In other words, not all program
        variables are explicitly defined by pseudo-ops ... some of them
        are transparently allocated in as needed by the assembler itself
        in memory locations not previously used for anything..&nbsp;
        Each numerically-unique constant is stored only once as a
        variable and is reused everywhere that requires it.&nbsp; For
        example, in the AS-206RAM LVDC assembly listing, <tt>=1B18</tt>
        is an operand in the lines with sequence numbers 051570 and
        051910, while <tt>=00000004</tt> is used at 051950 and 053380,
        but they both evaluate to the same numerical value and thus
        reference the same memory location (2-06-076).&nbsp; Note that
        if the literal numerical constant begins with the character 'O'
        (alphabetic, not digit) then the number is octal, while if the
        leading 'O' is not present then the number is decimal.<br>
      </li>
    </ol>
    <p>Except for the <tt>HOP</tt><tt></tt> instructions, the other CPU
      instructions that transfer program control target a location in
      the current IM/IS rather than a variable in the DM/DS, and thus
      require a different type of operand. Those instructions (<tt>TRA</tt>,
      <tt>TNZ</tt>, <tt>TMI</tt>) thus have operands in one of the
      following two formats:<br>
    </p>
    <ul>
      <li>The symbolic name of a code location in the current IM/IS.</li>
      <li>"<tt>*+<i>n</i></tt>" or "<tt>*-<i>n</i></tt>", where <tt><i>n</i></tt>
        is a literal decimal constant.&nbsp; This references the memory
        location <tt><i>n</i></tt> words later or earlier than the
        current instruction, respectively.&nbsp; (I say that the literal
        constant is <i>decimal</i> because yaASM.py implements it in
        that way.&nbsp; However, there are no instances of <tt><i>n</i></tt>&gt;7





















        in the existing LVDC source code, so I really have no way of
        knowing whether the original assembler accepted decimal
        constants or octal ones.)<br>
      </li>
    </ul>
    <ul>
    </ul>
    <p>Other exceptions:<br>
    </p>
    <ul>
      <li>The shift instruction, <tt>SHF</tt>, and the shorthand
        replacements for it, <tt>SHR</tt> and <tt>SHL</tt>.&nbsp; The
        latter two shorthand instructions take an operand of 0 or a
        positive decimal integer, and thus represent logical right or
        left shifts by a selectable number of positions.&nbsp; With "<tt>0</tt>"
        as the operand, as a special case, the accumulator is
        cleared.&nbsp; There are no uses of <tt>SHF</tt> in the
        existing source code, so while it must take an integer operand,
        I'm not sure whether it would be octal or decimal or something
        else.&nbsp; <b>Note:</b>&nbsp; <tt>SHR</tt> and <tt>SHL</tt>
        are implemented as <tt>SHF</tt> operations, but <tt>SHF</tt>
        can only shift by 1 or 2 positions.&nbsp; Therefore, if the
        operand for <tt>SHR</tt> or <tt>SHL</tt> is greater than 2,
        the assembler transparently converts the operation to a
        minimum-length sequence of <tt>SHL</tt><tt> 2</tt>, <tt>SHL 1</tt>,
        <tt>SHR 2</tt>, and <tt>SHR 1</tt> operations.&nbsp; For
        example, <tt>SHL 5</tt> assembles to <tt>SHL 2</tt> / <tt>SHL
          2</tt> / <tt>SHL 1</tt>.&nbsp; Consequently, depending on the
        operand, any given <tt>SHR</tt> or <tt>SHL</tt> may assemble
        to multiple executable words in memory rather than to a single
        word. </li>
      <li>The <tt>CDS</tt> instruction requires an operand of the form
        <tt><i>DM</i>,<i>DS</i>,<i>DUPDN</i></tt> where the three octal
        fields are interpreted, respectively, as specifying a
        HOP-constant-like data module (0-7), data sector (0-17), and
        duplex vs simplex mode (0-1).&nbsp; The <tt>DEQD</tt> pseudo-op
        (see below) can be used to create symbolic macro names for such
        specifications, and so the operand for <tt>CDS</tt> can be such
        a symbolic macro name as well.</li>
      <li>The <tt>EXM</tt> instruction has operands of the form "<tt><i>target</i>,<i>syllable</i>,<i>modifier</i></tt>",


































































        where <tt><i>target</i></tt>, <tt><i>syllable</i></tt>, and <tt><i>modifier</i></tt>
        are all small literal octal integer constants.&nbsp; These
        fields may be interpreted as follows:</li>
      <ul>
        <li><tt><i>target</i></tt> (0-3):&nbsp; Specifies offset in
          residual memory of target instruction:&nbsp; 0 for 600, 1 for
          640, 2 for 700, 3 for 740.<br>
        </li>
        <li><tt><i>syllable</i></tt> (0-1):&nbsp; Specifies syllable of
          the target instruction within the target word.<br>
        </li>
        <li><tt><i>modifier</i></tt> (0-17 octal):&nbsp; Specifies a
          4-bit modifier for the instruction:&nbsp; the two
          least-significant bits <i>replace</i> the corresponding bits
          in the target instruction, while the two most-significant bits
          <i>bitwise-OR</i> with the corresponding bits.<br>
        </li>
      </ul>
      <li>The <tt>PIO</tt> instruction accepts only literal octal
        constants (000-377).&nbsp; All of the examples I saw in the
        original LVDC printout were 0-padded, though yaASM.py does not
        enforce that restriction.<br>
      </li>
    </ul>
    <i><a name="Pseudo-ops"></a>Pseudo-ops</i>:&nbsp; The following
    table shows every type of pseudo-op I've encountered in the
    AS-206RAM and PTC ADAPT Self-Test program listings, and what I've
    been able to infer about them:<br>
    <br>
    <table width="100%" cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <th valign="middle" nowrap="nowrap" align="left">Pseudo-op<br>
          </th>
          <th valign="middle" align="left">Description<br>
          </th>
        </tr>
        <tr>
          <td valign="middle"><tt>BCI <i>text</i></tt><br>
          </td>
          <td valign="top">This pseudo-op appears only in PTC code.<br>
            <br>
            Its function is TBD, but I believe it encodes the <i><tt>text</tt></i>
            argument into 8 consecutive memory locations.&nbsp; The <i><tt>text</tt></i>
            always seems to end with a $ character.&nbsp; So perhaps $
            represents an end-of-buffer marker; or perhaps it represents
            a carriage-return/line-feed.&nbsp; These 8-location buffers
            could then be output later under program control to the
            PTC's printer peripheral device.&nbsp; The PTC source code
            contains a table of 64 patterns which could presumably be
            sent to the printer as character codes, and thus can be
            represented by 5 bits each.&nbsp; (The table appears
            left-hand symbol <tt>CHAR</tt> in the source code).&nbsp;
            Thus I suspect that each 26-bit buffer location could hold
            indices to as many as 5 characters, plus an extra bit for
            some other purpose, and the full output buffer would contain
            a total of 40 characters.&nbsp; In all samples of the <tt>BCI</tt>
            pseudo-op, <i><tt>text</tt></i> is indeed 40 characters or
            less.&nbsp; However, this is just speculation, and I have
            not yet worked out the details of the encoding scheme.<br>
            <br>
            See also the <tt>PRS</tt> CPU instruction.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" nowrap="nowrap"><tt>BSS</tt><tt> <i>n</i><br>
            </tt></td>
          <td valign="middle">This pseudo-op simply allocates <tt><i>n</i></tt>
            words of memory.&nbsp; They are loaded with the value 0.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" nowrap="nowrap"><tt>DEC</tt><tt> <i>number</i><br>
            </tt></td>
          <td valign="middle">This pseudo-op allocates one word of
            memory, and loads the decimal <tt><i>number</i></tt> in
            it.&nbsp; <br>
          </td>
        </tr>
        <tr>
          <td valign="middle" nowrap="nowrap"><tt>DEQD</tt><tt> </tt><tt><i>M</i></tt><tt>,</tt><tt><i>S</i></tt><tt>,</tt><tt><i>LOC<br>
              </i></tt><i>&nbsp; or</i><tt><i><br>
              </i></tt><tt>DEQS</tt><tt> </tt><tt><i>M</i></tt><tt>,</tt><tt><i>S</i></tt><tt>,</tt><tt><i>LOC</i></tt></td>
          <td valign="middle">This preprocessor pseudo-op is a variant
            of <tt>EQU</tt> (see below).&nbsp; It defines a
            pseudo-variable, named according to its left-hand symbol,
            referencing a specific fixed location in memory, specified
            by its module, sector, and offset, which are literal octal
            constants.&nbsp; Since the pseudo-variable exists only in
            the preprocessor, it does not store anything at that
            location, but merely defines a symbol representing that
            particular memory configuration.&nbsp; The symbol for the
            pseudo-variable created in this manner did not appear in the
            symbol tables produced by the original LVDC assembler, but
            do so in symbol tables produced by yaASM.py.&nbsp; As far as
            I know, those pseudo-variables are used only as operands of
            <tt>CDS</tt> instructions (see above).<br>
            <br>
            <tt>DEQD</tt> differs from <tt>DEQS</tt> in that the former
            specifies a duplex memory configuration whereas the latter
            specifies a simplex configuration.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" nowrap="nowrap"><tt>DFW</tt><tt> <i>inst</i><i>ruction1</i>,<i>operand1</i>,<i>instruction2</i>,<i>operand2</i><br>
            </tt></td>
          <td valign="middle">Assembles a constant which can
            subsequently be used as the operand of an <tt>EXM</tt>
            instruction (see earlier).&nbsp; Note that <tt>EXM</tt>
            cannot access such a constant in-place — i.e., not at the
            location where the <tt>DFW</tt> pseudo-op stores it —
            rather, requiring that the constant be moved at runtime to
            one of the addresses 200, 240, 300, or 340 in residual
            memory.<br>
            <br>
            Naively, what this pseudo-op does is to assembles two
            instructions (remember, each instruction assembles into one
            "syllable" and that two syllables comprise a single word of
            memory), allocate a word of memory, and store the assembled
            pair of instructions in it.&nbsp; However, because of the
            way <tt>EXM</tt> uses such assembled instructions, there
            are a few details which differ from this simple model.&nbsp;
            Specifically, the residual bit (A9) and least-significant
            bits (A2, A1) in <tt><i>operand1</i></tt> and <i><tt>operand2</tt></i>
            are modified from what you expect to include certain bits
            from the DS (data sector) applicable to <tt><i>operand1</i></tt>
            and <i><tt>operand2</tt></i>.&nbsp; The documentation for <tt>EXM</tt>
            should make it clear what those changes are. </td>
        </tr>
        <tr>
          <td valign="middle" nowrap="nowrap"><tt>DOG <i>DM,DS,DLOC</i><br>
            </tt><i>&nbsp;&nbsp; or</i><tt><br>
              DOGD </tt><tt><i>DM</i></tt><tt>,</tt><tt><i>DS</i></tt><tt>,</tt><tt><i>DLOC</i></tt><tt><br>
            </tt><i>&nbsp;&nbsp; or</i><br>
            <tt>DOGD </tt><tt><i>DM</i></tt><tt>,</tt><tt><i>DS</i></tt><tt>,</tt></td>
          <td valign="middle">Of the LVDC source code available to us,
            the <tt>DOG</tt> form appears only in the PTC ADAPT
            Self-Test Program, while the <tt>DOGD</tt> form appears
            only in the AS206-RAM Flight Program.&nbsp; It isn't known
            whether the two always remained available as synonyms or
            whether the one was deprecated in favor of the other.<br>
            <br>
            Abbreviated form of <tt>ORGDD</tt> (see below) that only
            modifies the assembler's current data-memory pointer,
            leaving the instruction-memory pointer untouched.&nbsp; It
            does not allocate any memory.&nbsp; The location parameter <tt><i>DLOC</i></tt>
            is treated as a suggestion rather than as a hard
            specification of the offset into the data-memory sector,
            since if the assembler finds that the requested <tt><i>DLOC</i></tt>
            has already been used, it will search upward through the
            data sector until it finds a location that hasn't already
            been used.&nbsp; If <tt><i>DLOC</i></tt> is omitted
            entirely, it is taken to be 000.<br>
            <br>
            Presumably there is a <tt>DOGS</tt> pseudo-op as well
            (differing in that it pertains to a simplex memory
            configuration rather than a duplex one), but I have not
            encountered it in actual code.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle"><tt>EQU (<i>expression</i>)</tt><br>
          </td>
          <td valign="middle">Defines a "pseudo variable" used only by
            the assembler's preprocessor pass.&nbsp; The parentheses are
            literally present.&nbsp; The expression is arithmetical in
            nature, and can involve decimal numbers, other pseudo
            variables, and the operations +, -, *, or /.&nbsp; The lines
            are evaluated in a single pass, so pseudo variables used in
            expressions need to have been defined earlier in the source
            code.&nbsp; For example,<br>
            <blockquote><tt>PI&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                EQU&nbsp;&nbsp;&nbsp; (3.1415927)</tt><br>
            </blockquote>
            Note that when pseudo variables are <i>used</i> they are
            always within arithmetical expressions that are enclosed in
            parentheses, <tt>(<i>expression</i>)</tt>, such as:<br>
            <blockquote><tt>PI&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                DEC&nbsp;&nbsp;&nbsp; (PI)B0<br>
                PI3&nbsp;&nbsp;&nbsp;&nbsp; DEC&nbsp;&nbsp;&nbsp;
                (3*PI)B0<br>
              </tt></blockquote>
            These examples also illustrate the important point that the
            namespace used for these pseudo variables is distinct from
            the namespace used for left-hand symbols naming variables or
            blocks of code.&nbsp; There are indeed symbols that have
            this double usage.&nbsp; For example, in the AS-206RAM
            program, "<tt>GEPLON EQU (15)</tt>" is at line 006600, while
            "<tt>GEPLON DEC (GEPLON)B10</tt>" is at line 016820.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle"><tt>FORM <i>a,b,</i>...</tt><br>
          </td>
          <td valign="middle">This preprocessor pseudo-op defines to the
            assembler (without generating any actual code) the name of a
            macro that, when used, will pack a pattern of bit-fields
            into a single word-size constant.&nbsp; In the <tt>FORM</tt>
            statement itself, the field-widths are decimal, whereas when
            the macro is used, the values of the fields are octal.&nbsp;
            An example may make all this clearer:<br>
            <blockquote><tt>MYPAT&nbsp;&nbsp;&nbsp;
                FORM&nbsp;&nbsp;&nbsp;&nbsp; 2,3,4,5,6</tt><tt><br>
              </tt><tt>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
                &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
                .</tt><tt><br>
              </tt><tt>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
                &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
                .</tt><tt><br>
              </tt><tt>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
                &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
                .</tt><tt><br>
              </tt><tt>MYCON&nbsp;&nbsp;&nbsp; MYPAT&nbsp;&nbsp;&nbsp;
                1,2,3,4,5<br>
              </tt></blockquote>
            The first of these lines defines a macro, <tt>MYPAT</tt>,
            which can pack 2-bit, 3-bit, 4-bit, 5-bit, and 6-bit fields
            into a single 20-bit field.&nbsp; Since the LVDC word-size
            is actually 26 bits, the unused 6 bits of the compiled
            constant will all be 0.&nbsp; Confusingly, the way the
            assembler <i>displays</i> word-size constants, the
            least-significant bit is always 0 (because it's the physical
            position in which parity is stored), so the constant is
            actually aligned at bit 27 and appears as exactly 9 octal
            digits.&nbsp; Because of this, in other words, it will
            really appear that there are 7 unused bits assigned the
            value 0.<br>
            <br>
            The second of the lines shown above uses the macro.&nbsp; It
            compiles such a constant and stores it at a the memory
            location <tt>MYCON</tt>.&nbsp; The 2-bit field will have
            the (binary) value 01, the 3-bit field will have the value
            010, and so on, so the actual value of <tt>MYCON</tt>, in
            binary, as displayed by the assembler, will be<br>
            <blockquote><tt>01 010 0011 00100 000101&nbsp;&nbsp; 000000
                0</tt><br>
            </blockquote>
            or octal 243101200.<br>
            <br>
            The LVDC flight program AS-206RAM defines three such macros,
            <tt>SS</tt>, <tt>SSFORM</tt>, and <tt>SSLAD</tt>, on page
            45.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" nowrap="nowrap"><tt>HPC</tt><tt> <i>SYMBOLNAME</i><br>
            </tt>
            <div align="left"><i>&nbsp;&nbsp; or</i><br>
            </div>
            <tt>HPC <i>SYMBOLNAME1</i>,<i>SYMBOLNAME</i><i>2</i><br>
            </tt></td>
          <td valign="middle">This allocates a word of memory at the
            current location, and stores a HOP constant in it that's
            constructed from the operand.&nbsp; <br>
            <br>
            In the one-operand variation, the HOP constant is simply the
            same as that of the symbol whose name is given by the
            operand.<br>
            <br>
            In the two-operand variation, IM, IS, S, and LOC fields of
            the HOP constant are taken from <tt><i>SYMBOLNAME1</i></tt>,
            while the DM and DS fields are taken from <tt><i>SYMBOLNAME</i><i>2</i></tt>.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" nowrap="nowrap"><tt>HPCDD</tt><tt> <i>arg1,arg2</i><br>
            </tt>
            <div align="left"><i>&nbsp;&nbsp; or</i><br>
            </div>
            <tt>HPCDD <i>IM,IS,S,LOC,DM,DS</i><i></i><br>
            </tt></td>
          <td valign="middle">Like <tt>HPC</tt> (see above), constructs
            a HOP constant and stores it at the current location.<br>
            <br>
            For all I know, there may be an <tt>HPCDS</tt> variation as
            well, differing from <tt>HPCDD</tt> in applying to a
            simplex memory configuration rather than a duplex one, but I
            have not encountered it in practice.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle"><tt>MAT</tt><br>
          </td>
          <td valign="top">Forces alignment for the next memory
            allocated to a 020-word (octal, or 16 decimal) boundary, and
            may have something to do with the succeeding words logically
            forming a matrix.&nbsp; It does not allocate any
            memory.&nbsp; I.e., any memory it skips past to reach the
            proper alignment remains unallocated. </td>
        </tr>
        <tr>
          <td valign="middle"><tt>OCT <i>number</i></tt><br>
          </td>
          <td valign="middle">Allocates a word of memory and stores the
            given octal <tt><i>number</i></tt> there.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle"><tt><tt>ORG <i>IM</i>,<i>IS</i>,<i>S</i>,<i>LOC</i>,<i>DM</i>,<i>DS,DLOC<br>
                </i></tt><i>&nbsp;&nbsp; or</i><tt><i><br>
                </i></tt></tt><tt>ORGDD <i>IM</i>,<i>IS</i>,<i>S</i>,<i>LOC</i>,<i>DM</i>,<i>DS,DLOC</i></tt><br>
          </td>
          <td valign="middle">Of the LVDC source code available to us,
            the <tt>ORG</tt> form appears only in the PTC ADAPT
            Self-Test Program, while the <tt>ORGDD</tt> form appears
            only in the AS206-RAM Flight Program.&nbsp; It isn't known
            whether the two always remained available as synonyms or
            whether the one was deprecated in favor of the other.<br>
            <br>
            Sets the instruction-memory and the data-memory assumptions
            for the next code or data lines to be assembled.&nbsp; The
            fields within the operand relate to those within the HOP
            constants, except that while the HOP constant has a single
            LOC field, the assembler internally maintains separate LOC
            fields for instruction memory (<i><tt>LOC</tt></i>) and data
            memory (<tt><i>DLOC</i></tt>).<br>
            <br>
            Some of the fields may be left empty, and those values are
            presumably left unchanged ... or rather kept as whatever
            their natural values would be if the <tt>ORG</tt> or <tt>ORGDD</tt>
            were not present.&nbsp; For example, with <tt>ORGDD</tt>,
            the trailing <tt><i>DLOC</i></tt> is sometimes not
            specified, so that we are left simply with "<tt>ORGDD <i>IM</i>,<i>IS</i>,<i>S</i>,<i>LOC</i>,<i>DM</i>,<i>DS,</i></tt>".&nbsp;




            In that case, the first previously-unused location in the
            select data module/sector is used.&nbsp; Actually, even
            specifying <tt><i>DLOC</i></tt> explicitly does not
            necessarily imply that the data location is set to <i><tt>DLOC</tt></i>,
            since if that location has already been used, the next
            unused location after that will be selected instead, and the
            assembler generates a warning message.&nbsp; With <tt>ORG</tt>,
            we find lots and lots of combinations of omitted fields.<br>
            <br>
            Actually, in general, in the modern LVDC assembler
            (yaASM.py), either of the <tt><i>LOC</i></tt> and <tt><i>DLOC</i></tt>
            fields as <i>suggestions</i> rather than used as-is,
            because the assembler will not move the location counters to
            addresses that have already been allocated:&nbsp; the
            assembler will always advance the counters until reaching
            the first unused location.&nbsp; The modern assembler was
            implemented that way, because it seemed to have been the
            behavior of the original assembler used for the AS206-RAM
            Flight Program assembly listing.&nbsp; However, it appears
            not to have been the behavior of the years-earlier assembler
            from the time of the PTC ADAPT Self-Test Program.&nbsp; For
            that earlier assembler, the <tt>ORG</tt> pseudo-op does not
            seem to have automatically advanced the program counter if
            location <tt>LOC</tt> was already occupied.&nbsp; Instead,
            the <tt>ORG</tt> could be followed by the <tt>TRA**</tt>
            pseudo-op (see below), and it was the <tt>TRA**</tt>
            pseudo-op that performed the advance.&nbsp; These
            distinctions (in retrospect) seem no longer to serve a
            purpose in the modern assembler, however, which treats <tt>ORG</tt>
            and <tt>ORGDD</tt> as identical and ignores <tt>TRA**</tt>
            altogether.<br>
            <br>
            There may be an <tt>ORGDS</tt> variant as well, specifying
            a simplex memory configuration rather than a duplex
            configuration, but I have not encountered it in practice.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle"><tt>SYN <i>symbol</i></tt><br>
          </td>
          <td valign="middle">This pseudo-op requires a left-hand symbol
            to precede the <tt>SYN</tt> on the line.&nbsp; It tells the
            assembler to treat the left-hand symbol as a synonym for <tt><i>symbol</i></tt>.&nbsp;





















            This is similar in concept to <tt>EQU</tt>, which
            essentially creates synonyms for numerical constants.&nbsp;
            But it differs from <tt>EQU</tt> in that it is not a part
            of the preprocessor, and thus can reference symbols defined
            later in the source code.&nbsp; Further, the symbols it
            references can be program labels or variable names <br>
          </td>
        </tr>
        <tr>
          <td valign="middle"><tt>TABLE <i>number</i></tt><br>
          </td>
          <td valign="middle">This informs the assembler that the
            succeeding <tt><i>number</i></tt> words of memory form a
            table.&nbsp; The operand is a decimal number.&nbsp; The only
            use I can see for this is to make sure the assembler doesn't
            split the table across a memory-sector boundary.&nbsp; All
            of the uses of <tt>TABLE</tt> I find in the AS-206RAM
            listing are tagged as assembler warnings.<br>
          </td>
        </tr>
        <tr>
          <td valign="top"><tt>TRA**</tt><br>
          </td>
          <td valign="top">This pseudo-op appears in PTC code only (not
            LVDC), and advances the program counter (at assembly time
            rather than at runtime) to the first unused memory location
            in the current instruction module/sector/syllable.&nbsp;
            Since the modern assembler (yaASM.py) performs this function
            automatically and transparently anyway, <tt>TRA**</tt> no
            longer has any purpose, and is simply ignored by the
            assembler.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" nowrap="nowrap"><tt>USE</tt><tt> INST<i><br>
              </i></tt><i>&nbsp; or</i><tt><i><br>
              </i>USE DAT<i><br>
              </i> </tt></td>
          <td valign="middle">These pseudo-ops alter the way the
            assembler places and orders succeeding items in
            memory.&nbsp; The usual positioning and ordering is
            represented by <tt>USE INST</tt>, whereas I'm unsure of
            what <tt>USE DAT</tt> is for.&nbsp; I think it may be a
            convenient way to pack CPU instructions when one wants to
            place them in the midst of an area of memory used primarily
            for storing variables, or may represent an alternative to
            the <tt>DFW</tt> pseudo-op (see above).<br>
            <br>
            <tt>USE INST</tt>:<br>
            <blockquote>The <tt>ORGDD</tt> pseudo-op (see above)
              defines an origin for both "instructions" (fields <tt><i>IM</i>,<i>IS</i>,<i>S</i>,<i>LOC</i></tt>)
              and "data" (fields <tt><i>DM</i>,<i>DS,LOC2</i></tt>).&nbsp;
































              Normally, instructions are assembled at successive offset
              locations while the "syllable" (0 or 1) is kept
              fixed.&nbsp; I.e., normally, all of the locations with
              syllable 0 are used up, then all of the locations with
              syllable 1.&nbsp; The assembler uses the <tt><i>IM</i>,<i>IS</i>,<i>S</i>,<i>LOC</i></tt>
              fields from <tt>ORGDD</tt> to determine the memory area
              in which this happens.&nbsp; When the end of the memory
              sector is reached, a different syllable or sector or
              module must be selected either by the assembler or the
              coder.&nbsp; <br>
              <br>
              Data is similarly assembled at successive locations (with
              pseudo-ops like <tt>DEC</tt>, <tt>OCT</tt>, or <tt>BSS</tt>),
































              but in the memory area selected by the <tt><i>DM</i>,<i>DS,LOC2</i></tt>
              fields from <tt>ORGDD</tt> instead.&nbsp; Moreover, data
              is typically a full word of memory rather than a single
              syllable, so both syllables of each memory word are
              typically used for each data item.<br>
            </blockquote>
            <tt>USE DAT</tt>:<br>
            <blockquote>On other other hand, when <tt>USE DAT</tt> is
              in effect, I think only instructions are assembled, and
              data-allocated pseudo-ops like <tt>DEC</tt>, <tt>OCT</tt>,
              or <tt>BSS</tt> aren't used.&nbsp; There are two changes
              from <tt>USE INST</tt> in the way instructions are
              assembled.&nbsp; <br>
              <br>
              Firstly, instructions are assembled in the memory area
              selected by the <tt><i>DM</i>,<i>DS,LOC2</i></tt> fields
              from <tt>ORGDD</tt>.&nbsp; I.e., they appear in "data"
              memory rather than in "instruction" memory.&nbsp; But
              beyond that, successive instructions are not assembled
              into the same syllable of memory, but are instead
              assembled at alternating syllables: 1, 0, 1, 0, 1, 0,
              .....&nbsp;&nbsp; (Notice that syllable 1 comes first in
              the sequence.)<br>
              <br>
              I'm not sure how the CPU responds to this ordering.&nbsp;
              The <tt>USE DAT</tt> context is often (though not always)
              associated with simplex memory configuration as selected
              by a <tt>CDSS</tt> instruction so perhaps this is really
              the order in which the CPU executes instructions in a
              simplex configuration.<br>
            </blockquote>
          </td>
        </tr>
        <tr>
          <td valign="middle" nowrap="nowrap"><tt>VEC</tt><tt><br>
            </tt></td>
          <td valign="middle">Forces alignment on a 4-word boundary, and
            may have something to do with the succeeding words logically
            forming a vector.&nbsp; It does not allocate any
            memory.&nbsp; I.e., any memory it skips past to reach the
            proper alignment remains unallocated.<br>
          </td>
        </tr>
      </tbody>
    </table>
    <h3><a name="ANATOMY"></a>Program Structure </h3>
    <p>Here are some of my own observations and inferences, based on
      inspection of the AS-206RAM assembly listing.<br>
    </p>
    <p>Overall structure of the program: <br>
    </p>
    <ul>
      <li>Code:</li>
      <ul>
        <li>Table of contents<br>
        </li>
        <li>Explanatory comments about telemetry data.</li>
        <li>Pseudo variables definitions<br>
        </li>
        <li>Code-entry points which are obliged to be at specific memory
          locations.&nbsp; (interrupt, initialization, timing "minor
          loop", abort)</li>
        <li>Orbital program linkages.</li>
        <li>Macro definitions.</li>
        <li>Utility programs required to be at specific memory
          locations.&nbsp; I notice that some of this code is
          self-modifying.&nbsp; Perhaps that may be part of the
          motivation for putting it at a specific location.&nbsp;
          Perhaps not.</li>
        <li>Data storage area.&nbsp; I.e., variables and constants ...
          but there is also a smidgeon of code stored here (go figure!),
          for managing the switch-selector table.&nbsp; Of particular
          bulk are:</li>
        <ul>
          <li>Switch selector table</li>
          <li>C-band and telemetry station table.</li>
        </ul>
        <li>Section 1:&nbsp; Initialization</li>
        <li>Section 2: Accelerometer processing.</li>
        <li>Section 3: Boost navigation.</li>
        <li>Section 4:&nbsp; Guidance select and pre-IGM guidance.</li>
        <li>Section 5: IGM guidance.</li>
        <li>Section 6: Backup routines</li>
        <li>Section 7: Interrupt routines</li>
        <li>Section 8: Orbital initialization</li>
        <li>Section 9: Orbital processor</li>
        <li>Section 10: Orbital navigation</li>
        <li>Section 11: C-band and telemetry navigation routine</li>
        <li>Section 12: Acceleration routines</li>
        <li>Section 13: Orbital guidance</li>
        <li>Section 14: Interrupt processing</li>
        <li>Section 15: Simultaneous memory error (Tough Luck Charlie)</li>
        <li>Section 16: Minor loop support</li>
        <li>Section 17: Minor loop</li>
        <li>Section 18: Disagreement bit processing</li>
        <li>Minor loop error telemetry routine</li>
        <li>Section 19: Switch selector check</li>
        <li>Section 20: Switch selector processing</li>
        <li>Section 21: Flight simulation</li>
        <li>Section 22: Utility Routines<br>
        </li>
      </ul>
      <li>Tables generated by the assembler:</li>
      <ul>
        <li>Segment cross reference table</li>
        <li>Octal memory listing<br>
        </li>
      </ul>
    </ul>
    <p>Assembly warnings:&nbsp; Warnings are marked with a <tt>W</tt>
      in the leftmost column of the offending line.&nbsp; No explanation
      appears in the assembly listing of why any particular warning is
      issued.&nbsp; In the AS-206RAM assembly listing, the sequence
      numbers at which errors and warnings are found is as follows:<br>
    </p>
    <blockquote><tt>012420 015020 015050 015070 015090 015110 015140
        015260 015290 015310 <br>
        026500 026800 026820 026840 026880 026920 026990 027020 027820
        027890 <br>
        027910 027980 028040 028090 029370 030230 031780 031930 032230
        036880 <br>
        036910 036920 036930 036950 036990 037020 037200 037490 038040
        038680 <br>
        038820<br>
      </tt></blockquote>
    <p>Sector shifts in the program flow:&nbsp; Recall that each 26-bit
      word of memory (not including the parity bit) consists of two
      13-bit syllables, referred to as syllable 0 and syllable 1.&nbsp;
      Each CPU instruction assembles to a single 13-bit value, and thus
      fits precisely within a single syllable, and any word in memory
      can simultaneously hold two separate instructions.&nbsp; When the
      CPU executes code in a given memory sector, it just sequences
      through all of the instructions in the currently-selected
      syllable.&nbsp; When the last-available word in the current
      syllable is reached, execution cannot continue.&nbsp; Rather than
      forcing the programmer to deal with this situation explicitly, the
      assembler steps in and transparently substitutes an extra
      instruction into the program flow to select a different syllable,
      sector, or module.&nbsp; So from the programmer's standpoint, he
      can just write an uninterrupted block of code without even
      worrying about the fact that it spans several different memory
      sectors.&nbsp; The code transparently modified by the assembler
      uses slightly more memory and execution time that it superficially
      appears to from the source code, but that <i>usually</i> doesn't
      matter.&nbsp; <br>
    </p>
    <p>From the assembler's point of view, though, it's a bit more
      complicated.&nbsp; The simplest case is in reaching the end of
      syllable 0 for a given memory sector.&nbsp; The first (unused)
      location of syllable 1 of that same memory sector is accessible by
      a <tt>TRA</tt> instruction, so the assembler transparently
      inserts a <tt>TRA</tt> just before reaching the end of syllable
      0.<br>
    </p>
    <p>What happens when reaching the end of syllable 1 of a memory
      sector is much trickier.&nbsp; For one thing, various factors
      influence the usage of words at the ends of sectors in syllable 1,
      so it's a chore for the assembler just to figure out when the end
      of sector 1 has even been reached.&nbsp; The next problem is that
      once the end of syllable 1 has been reached, it can't simply
      switch to a new syllable:&nbsp; it instead has to switch to a
      different <i>sector</i> within the memory module, or perhaps even
      to a different memory module altogether.&nbsp; That can't be done
      with a simple <tt>TRA</tt> instruction, and requires a
      more-complex <tt>HOP</tt> instruction instead.&nbsp; Unlike a <tt>TRA</tt>
      instruction which encodes its target address within the
      instruction itself, a <tt>HOP</tt> instruction requires a
      variable containing the "HOP constant" of the target
      address.&nbsp; Naturally, no such variable containing the desired
      HOP constant normally exists.&nbsp; So in order to insert a <tt>HOP</tt>
      instruction, the assembler must first create such a
      variable:&nbsp; it must find an unused location in the current
      data sector or residual sector, and stick a HOP constant into it.</p>
    Those points at which a sector change is performed due to reaching
    the end of the sector, regardless of whether or not the assembler
    inserts any <tt>HOP</tt> or <tt>TRA</tt> instructions, is marked
    with a <tt>*</tt> in column 1 of the assembly listing.&nbsp; These
    transparently-inserted jumps are found at the following
    card-sequence numbers in the AS-206RAM listing:<br>
    <blockquote>
      <p><tt>044700 047910 050170 052790 054910 057850 062640 065020
          067470 070680 <br>
          073610 076720 079190 083030 085700 089420 093330 096170 098760
          101450<br>
          104090 109850 112570 116390 120760 123850&nbsp; <br>
        </tt></p>
    </blockquote>
    <p>Assembly errors:&nbsp; Errors are marked in the leftmost column
      of the offending line by a character that presumably indicates the
      type of error.&nbsp; In the AS-206RAM assembly listing, the 7 such
      errors are found, and here are my interpretations of what they
      mean:<br>
    </p>
    <ul>
      <li><tt>U</tt> at sequence number 027140.&nbsp; The operand, <tt>CBNAV</tt>,
        is not a defined symbol.&nbsp; It appears as though it was
        probably correct in earlier software versions, but perhaps
        should have been changed to <tt>CBNAV1</tt> in this version.<br>
      </li>
      <li><tt>U</tt> at sequence number 029650.&nbsp; One of the macro
        parameters, <tt>CBRANW</tt>, is not a defined symbol.&nbsp;
        There is a handwritten note implying that it probably should
        have been <tt>TEMP6</tt>.</li>
      <li><tt>O</tt> (no sequence number, p. 67).&nbsp; This is a
        full-line comment, but the necessary "<tt>*</tt>" character in
        column 1 has apparently been accidentally omitted.&nbsp;
        Therefore, the first word in the line (which happens to be "+")
        has been interpreted as an instruction, and naturally the
        assembler knows of no such instruction. <br>
      </li>
      <li><tt>V</tt> at sequence number 047930.&nbsp; The assembler
        mistakenly believes the target location, <tt>*-2</tt>,&nbsp; is
        out of range, because it has been fooled by an automatic switch
        from memory syllable 0 to syllable 1 slightly before.&nbsp; In
        fact, the target location actually <i>is</i> accessible by a <tt>TRA</tt>
        instruction (or a <tt>HOP</tt> instruction), but presumably the
        original assembler was not smart enough to figure that out.<br>
      </li>
      <li><tt>U</tt> (no sequence number, p. 187). The target location,
        <tt>TB5GO</tt>, is an undefined symbol.<br>
      </li>
      <li><tt>A</tt> (no sequence number, p. 188). The target variable,
        <tt>TBB</tt>, is defined, but is not located in either the
        current data sector or in the residual sector, and is therefore
        not accessible.<br>
      </li>
      <li><tt>O</tt> (no sequence number, p. 190). The target location
        of a jump, <tt>ORBGID</tt>, is not located in the current data
        sector.&nbsp; The instruction is <tt>TRA</tt>, and ordinarily
        that means that the assembler would automatically have used a <tt>HOP</tt>
        instruction in place of the <tt>TRA</tt>. For reasons that are
        unclear to me, the original assembler did not do so in this
        case, and instead simply discarded the instruction.<br>
      </li>
    </ul>
    <p>Notice that about half of the errors above occur on the (rare!)
      lines having no card-sequence number.&nbsp; I think that for
      pragmatic reasons, sequence numbers would usually have been left
      off of the punch-cards while the code was under development.&nbsp;
      Otherwise, they would have needed to be changed frequently, which
      would be a great inconvenience.&nbsp; In other words, the sequence
      numbers were likely only added once the code had reached a
      releasable form.&nbsp; Thus most of the errors appeared in areas
      of the code that were under active development, which is not
      terribly surprising.<br>
    </p>
    <p>Alas!&nbsp; There are 7 <i>more</i> errors exactly like the <tt>A</tt>
      type error listed above which the original assembler did not even
      detect.&nbsp; These are the pairs of lines of code at
      card-sequence numbers 026840, 026860, 026880, 026900, 026920,
      026940, and 026960.&nbsp; They're all of the form<br>
    </p>
    <blockquote><tt><i>LABEL</i>&nbsp;&nbsp; CLA&nbsp;&nbsp;&nbsp; <i>CONSTANT</i><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLA&nbsp;&nbsp;&nbsp;
        <i>CONSTANT</i>+1<br>
      </tt></blockquote>
    <p> </p>
    <p>Fortunately, it's easy to see how these latter 7 errors should be
      fixed.&nbsp; As it happens, there are quite a few examples on the
      same page of the assembly listing that make it clear the pattern
      should have instead been <br>
    </p>
    <blockquote><tt><i>LABEL</i>&nbsp;&nbsp; CDS &nbsp;&nbsp; <i>CONSTANT</i><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLA&nbsp;&nbsp;&nbsp;
        <i>CONSTANT</i>+1<br>
      </tt></blockquote>
    Format of the source-code portion of the assembly listing:&nbsp;
    Consider a "normal" section of the listing, containing code,
    comments, etc., as opposed to report tables generated by the
    assembler, to which I've added some markup (in green) for
    explanatory purposes:<br>
    <div align="center"><img alt="" src="anatomyCode.jpg" width="1005"
        height="310"> </div>
    <ul>
      <li>Columns IM, IS, S, LOC, DM, and DS:&nbsp; These columns are
        generated by the assembler and represent <a
          href="#Layout_of_Memory_Words">the fields of the HOP constant</a>
        associated with the line of code, from the viewpoint of the
        assembler.&nbsp; (The only HOP fields missing are DUPIN and
        DUPDN, which I suppose would be global settings affecting all
        memory, as opposed to varying on a line by line basis.)&nbsp; In
        particular, the IM and IS fields give the memory module and
        sector in which the line of code appears, and LOC gives the
        offset into the memory sector of the word in which the code for
        the instruction is stored.</li>
      <li>Columns A8-A1, A9, and OP:&nbsp; These columns are also
        generated by the assembler, and represent <a
          href="#Layout_of_Memory_Words">fields of the assembled
          instruction</a> associated with the line of code.&nbsp; In
        particular, OP is the octal value of the particular CPU
        instruction, <a href="#CPU_Instructions">as tabulated earlier</a>.<br>
      </li>
      <li>Column CONSTANT:&nbsp; Yet another field generated by the
        assembler.&nbsp; Most lines don't have it, but it appears
        whenever the operand of the instruction is the address of a
        numerical constant stored at some other place in memory, but for
        which the assembler knows the value.&nbsp; For example, both of
        the lines in the sample above are the same, 342452244, because
        both of them relate to a <tt>HOP SCPOLY</tt> instruction.&nbsp;
        As I've already explained above, what the assembler does with a
        line of code like this is to find the <tt>SCPOLY</tt> routine
        (which conveniently for us, actually appears in sample above as
        well), figures out its HOP constant, allocates a word of memory,
        stores the HOP constant at that location, and then embeds the
        address of that location into the instruction.&nbsp; You can
        actually see all that happening in the sample.&nbsp; The HOP
        constant itself corresponds to the values IM=4, IS=04, S=1,
        LOC=124, DM=2, DS=14 at the line of code <tt>SCPOLY STO 777</tt>.&nbsp;






























































        I know it's probably tough to do those conversions in your head,
        so a handy python script (<a
href="https://github.com/virtualagc/virtualagc/blob/master/yaASM.py/unHOP.py">unHOP.py</a>)
        is available that can do it for you; and in fact, if you feed
        342452244 into unHOP.py, the expected values of IM, IS, S, etc.,
        pop out.&nbsp; (You also get the extra info that DUPIN=1 and
        DUPDN=1 ... more on which below.)&nbsp; Moreover, if you look at
        the lines where the constant appears, namely the lines reading
        <meta http-equiv="content-type" content="text/html;
          charset=UTF-8">
        <tt>HOP SCPOLY</tt>, and you look at the assembled code, you'll
        see that the address at which the HOP constant is stored must be
        DM=2, DS=14, LOC=342.</li>
      <li>Column EXPANSION:&nbsp; The final field generated by the
        assembler.&nbsp; It contains the character '+' for instructions
        which have been expanded from the <tt>CALL</tt> macro, but is
        blank otherwise.&nbsp; Whether there are other things that can
        appear there, I can't say.</li>
      <li>Columns LEFT-HAND SYMBOL, INSTRUCTION, OPERAND, COMMENT,
        SEQUENCE:&nbsp; I've covered these above, and suspect that they
        may come directly from the punch cards, unchanged.</li>
    </ul>
    The Segment Cross Reference table:&nbsp; This appears near the end
    of the assembly listing, and is generated by the assembler.&nbsp;
    Here's a small sample:<br>
    <br>
    <div align="center"><img alt="" src="anatomyXref.jpg" width="1328"
        height="74"><br>
    </div>
    <p>What the cross reference does is list each symbol in the program,
      tell you where it appears in memory, and then tells you how to
      find all <i>uses</i> of that symbol in the code.&nbsp; It should
      be pretty obvious to you that in this example, the symbol <tt>UTEMP1</tt>
      is in memory module 2, sector 17, at address 174.&nbsp; It may or
      may not be obvious that where the symbol is <i>used</i> is at the
      line SEQUENCE numbers 085370, 116640, etc.&nbsp; Alas, the few
      pages of the assembly listing which I've elected to freely expose
      do not include the one which <tt>UTEMP1</tt> is allocated, but
      does include several examples of where it is used.&nbsp; For
      example, if you look at the sample code I've marked up in green
      just a bit above, you can see it used at SEQUENCE number 117600,
      just as expected.&nbsp; Not all lines of code have SEQUENCE
      numbers, and in those cases the SEQUENCE number appearing in the
      table are generated by simply adding 10 to last card having an
      explicit SEQUENCE number.<br>
    </p>
    <p>Although I haven't shown any examples in the image above, memory
      locations which the assembler itself automatically allocates also
      appear in the segment cross reference table.&nbsp; Recall that
      there are cases where the assembler transparently allocates memory
      locations to store values of constants (like the values of
      numerical expressions or HOP constants) which are referenced
      on-the-fly without being explicitly defined in the source
      code.&nbsp; These variables are distinguished by having no
      symbolic name.&nbsp; Instead they are referenced by their unique
      values rather than by symbolic name.&nbsp; I.e., their unique
      values are used as if they were their symbolic names.&nbsp; Hence
      what appears in the table in place of a name is the 9-octal-digit
      value stored at the location.&nbsp; They appear in the table after
      all of the symbolic names.<br>
    </p>
    <p>The octal listing of the program:&nbsp; This is generated by the
      assembler and appears at the very end of the listing.&nbsp; It
      simply shows what appears at each memory location in the modules,
      as either a single 26-bit octal word or as two 13-bit
      syllables.&nbsp; So you can see in the octal table what each
      instruction and each pseudo-op assembles to in octal form.&nbsp;
      In each of the numbered columns of the table, syllable 1 of the
      memory word is on the left and syllable 0 is on the right.&nbsp;
      For example, referring to the image below, in module 2, sector 00,
      location 0201 (or 2-00-0201 for short), syllable 1 has the value
      10170 and syllable 0 has the value 00174.&nbsp; <br>
    </p>
    <p>It's important to understand the alignment of the data shown in
      the octal listing:<br>
    </p>
    <ul>
      <li>26-bit data words (none of which are shown below) are shifted
        1 bit to the left, and thus displayed as 9 octal digits.&nbsp;
        The least-significant bit is always 0.</li>
      <li>13-bit instructions, syllable 1, are shifted 2 bits to the
        left, and thus displayed as 5 octal digits.&nbsp; The
        least-significant 2 bits are always 0.</li>
      <li>13-bit instructions, syllable 0, are shifted 1 bit to the
        left, and thus displayed as 5 octal digits.&nbsp; The
        most-significant and least-significant bit are always 0.</li>
    </ul>
    <p>This seems weird — the instruction alignment in particular! — but
      I suppose the rationale is that the open bit positions correspond
      to the positions of parity bits.&nbsp; The assembler itself does
      not bother to compute the parity bits for you, and thus represents
      them all as 0.&nbsp; If you take an instruction from syllable 1
      and one from syllable 0 as shown in the table, overlap the
      least-significant <i>octal digit</i> from the left-hand
      instruction with the most-significant octal digit from the
      right-hand instruction, then bitwise OR them (or add them), you
      get the full contents of the memory word.&nbsp; For example,
      taking the first two instructions shown below (63224 12436), the
      full 26-bit content of address 2-00-000, left-aligned, is:<br>
    </p>
    <blockquote><tt>&nbsp; 63224<br>
        +&nbsp;<u>&nbsp;&nbsp;&nbsp; 12436</u><br>
        &nbsp; 632252436<br>
      </tt></blockquote>
    <p>However, there's no doubt that the visual representation of this
      data is undoubtedly weird.&nbsp; And, it's unclear just how useful
      it is ... certainly not at all, if you're trying to disassemble
      the instructions by eye!&nbsp; I've provided a handy python script
      (<a
href="https://github.com/virtualagc/virtualagc/blob/master/yaASM.py/unOP.py">unOP.py</a>)
      that you can use to provide a simple-minded disassembly of the
      instructions found in the octal listing.&nbsp; The script assumes
      that if an octal number you give it has a leading space character
      then it is in syllable 0, and that if it has no leading space it
      is in syllable l.&nbsp; For example, feeding "63224" into it gives
      back "MPH 315", while feeding " 12436" into it gives back "CLA
      124".<br>
    </p>
    <div align="center"><img alt="" src="anatomyOctal.jpg" width="1114"
        height="134"><br>
    </div>
    &nbsp;<br>
    <p> </p>
    <h2><a name="MIT_Instrumentation_Laboratory_vs_IBM"></a>MIT
      Instrumentation Laboratory vs IBM Federal Systems Division</h2>
    The MIT Instrumentation Laboratory (which designed the Apollo
    Guidance Computer) had nothing to do with the LVDC, and conversely
    IBM Federal Systems Division (which designed the LVDC) had nothing
    to do with the AGC.&nbsp; However, since IBM was an important
    manufacturer of computers (indeed, it designed the Gemini on-board
    computer system), whereas MIT/IL was emphatically <i>not</i>, there
    was an understandable feeling by some that the Apollo program might
    better be served by an IBM on-board guidance computer in the Command
    Module and Lunar Module than by newly-designed computer from novice
    MIT/IL.<br>
    <br>
    Accordingly, IBM proposed that the LVDC be used in place of the AGC
    in the CM and LM, and in 1963, it produced a big, two volume report
    (<a href="Documents/IBMStudyReport-63-928-129-Volume1.pdf">here</a>
    and <a href="Documents/IBMStudyReport-63-928-130-Volume2.pdf"> here</a>)
    to support their proposal.&nbsp; The Instrumentation Labs fired back
    their own critiques, shredding IBM's report to the extent
    possible.&nbsp; And in <a
      href="Documents/CritiqueOfIBMApolloStudyReport.pdf"> one of those
      critiques</a>, we have a few precious gems of LVDC assembly
    language, as written by the Instrumentation Labs personnel rather
    than by IBM.&nbsp;<br>
    <br>
    Whether it's a good LVDC program or a bad one, who knows?&nbsp; It
    certainly seems to depart a tad from the syntax of actual IBM code;
    for example, what MIT calls <tt>HOPCON</tt>, IBM calls <tt>HPC</tt>.
    &nbsp; But here's what it looked like.&nbsp; The '#' characters
    indicate the beginnings of comments.&nbsp; Those comments were added
    by me, and weren't present in the samples originally.<br>
    <br>
    <table summary="" style="text-align: left; margin-left: auto;
      margin-right: auto;" cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <td style="vertical-align: top; background-color: rgb(204,
            255, 255);"> <small><span style="font-family: Courier
                New,Courier,monospace;"># Sum of two double-precision
                vectors A and B to produce&nbsp; vector C.</span><br
                style="font-family: Courier New,Courier,monospace;">
              <span style="font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
CLA&nbsp;&nbsp;&nbsp;&nbsp;












































































                A<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                ADD&nbsp;&nbsp;&nbsp;&nbsp; B<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                STO&nbsp;&nbsp;&nbsp;&nbsp; C<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                CLA&nbsp;&nbsp;&nbsp;&nbsp; A + 1<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                ADD&nbsp;&nbsp;&nbsp;&nbsp; B + 1<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                STO&nbsp;&nbsp;&nbsp;&nbsp; C + 1<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                CLA&nbsp;&nbsp;&nbsp;&nbsp; A + 2<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                ADD&nbsp;&nbsp;&nbsp;&nbsp; B + 2<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                STO&nbsp;&nbsp;&nbsp;&nbsp; C + 2<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>
                <br>
                # Purportedly, subroutine linkages to call functions to
                perform vector addition.<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                CLA&nbsp;&nbsp;&nbsp;&nbsp; ADRESA<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                STO&nbsp;&nbsp;&nbsp;&nbsp; VCAADR<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                CLA&nbsp;&nbsp;&nbsp;&nbsp; * + 2<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                HOP&nbsp;&nbsp;&nbsp;&nbsp; VCALINK<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                HOPCON&nbsp; * + 1<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                CLA&nbsp;&nbsp;&nbsp;&nbsp; ADRESB<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                STO&nbsp;&nbsp;&nbsp;&nbsp; VADADR<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                CLA&nbsp;&nbsp;&nbsp;&nbsp; * + 2<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                HOP&nbsp;&nbsp;&nbsp;&nbsp; VADLINK<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                HOPCON&nbsp; * + 1<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                CLA&nbsp;&nbsp;&nbsp;&nbsp; CADRES<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                STO&nbsp;&nbsp;&nbsp;&nbsp; VTSADR<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                CLA&nbsp;&nbsp;&nbsp;&nbsp; * + 2<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                HOP&nbsp;&nbsp;&nbsp;&nbsp; VTSLINK<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                HOPCON&nbsp; * + 1<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>
                <br>
                # Integration during accelerated flight. If you want to
                see the equations being<br>
                # implemented, look at page 7 of <a
                  href="Documents/CritiqueOfIBMApolloStudyReport.pdf">
                  the critique</a>.<br>
                AVERAGEG STO&nbsp;&nbsp;&nbsp;&nbsp; EXITHOP<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                HOP&nbsp;&nbsp;&nbsp;&nbsp; HOPSET1<br>
                AVG1&nbsp;&nbsp;&nbsp;&nbsp; CLA&nbsp;&nbsp;&nbsp;&nbsp;
                WK<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                SHF&nbsp;&nbsp;&nbsp;&nbsp; R1<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                ADD&nbsp;&nbsp;&nbsp;&nbsp; HGK/2<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                ADD&nbsp;&nbsp;&nbsp;&nbsp; VK<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                MPH&nbsp;&nbsp;&nbsp;&nbsp; H<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                ADD&nbsp;&nbsp;&nbsp;&nbsp; R<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                STO&nbsp;&nbsp;&nbsp;&nbsp; R<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                MPY&nbsp;&nbsp;&nbsp;&nbsp; R<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                HOP&nbsp;&nbsp;&nbsp;&nbsp; THISEC1<br>
                AVG4&nbsp;&nbsp;&nbsp;&nbsp; CLA&nbsp;&nbsp;&nbsp;&nbsp;
                HOPWD1<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                ADD&nbsp;&nbsp;&nbsp;&nbsp; ONE<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                STO&nbsp;&nbsp;&nbsp;&nbsp; HOPWD1<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                CLA&nbsp;&nbsp;&nbsp;&nbsp; PQ<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                ADD&nbsp;&nbsp;&nbsp;&nbsp; DOTSUM<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                STO&nbsp;&nbsp;&nbsp;&nbsp; DOTSUM<br>
                HOPWD1&nbsp;&nbsp; HOP&nbsp;&nbsp;&nbsp;&nbsp; HOPSET1<br>
                AVG2&nbsp;&nbsp;&nbsp;&nbsp; CLA&nbsp;&nbsp;&nbsp;&nbsp;
                DOTSUM<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                STO&nbsp;&nbsp;&nbsp;&nbsp; SQRTARG<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                CLA&nbsp;&nbsp;&nbsp;&nbsp; * + 2<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                HOP&nbsp;&nbsp;&nbsp;&nbsp; SQRTLINK<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                HOPCON&nbsp; * + 1<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                CLA&nbsp;&nbsp;&nbsp;&nbsp; SQRTANS<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                MPY&nbsp;&nbsp;&nbsp;&nbsp; DOTSUM<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                CLA&nbsp;&nbsp;&nbsp;&nbsp; -MUH/2<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NOOP<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NOOP<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                DIV&nbsp;&nbsp;&nbsp;&nbsp; PQ<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                HOP&nbsp;&nbsp;&nbsp;&nbsp; THISSEC2<br>
                AVG5&nbsp;&nbsp;&nbsp;&nbsp; CLA&nbsp;&nbsp;&nbsp;&nbsp;
                HOPSET1<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                STO&nbsp;&nbsp;&nbsp;&nbsp; HOPWD1<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                CLA&nbsp;&nbsp;&nbsp;&nbsp; HOPSET2<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                STO&nbsp;&nbsp;&nbsp;&nbsp; HOPWD2<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NOOP<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NOOP<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NOOP<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                CLA&nbsp;&nbsp;&nbsp;&nbsp; PQ<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                STO&nbsp;&nbsp;&nbsp;&nbsp; DOTSUM<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                HOP&nbsp;&nbsp;&nbsp;&nbsp; HOPSET2<br>
                AVG3&nbsp;&nbsp;&nbsp;&nbsp; CLA&nbsp;&nbsp;&nbsp;&nbsp;
                R<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                MPY&nbsp;&nbsp;&nbsp;&nbsp; DOTSUM<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                CLA&nbsp;&nbsp;&nbsp;&nbsp; HGK/2<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                ADD&nbsp;&nbsp;&nbsp;&nbsp; W<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                ADD&nbsp;&nbsp;&nbsp;&nbsp; V<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                STO&nbsp;&nbsp;&nbsp;&nbsp; V<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                CLA&nbsp;&nbsp;&nbsp;&nbsp; PQ<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                STO&nbsp;&nbsp;&nbsp;&nbsp; HGK/2<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                ADD&nbsp;&nbsp;&nbsp;&nbsp; V<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                STO&nbsp;&nbsp;&nbsp;&nbsp; V<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                HOP&nbsp;&nbsp;&nbsp;&nbsp; THISSEC3<br>
                AVG6&nbsp;&nbsp;&nbsp;&nbsp; CLA&nbsp;&nbsp;&nbsp;&nbsp;
                HOPWD2<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                ADD&nbsp;&nbsp;&nbsp;&nbsp; ONE<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                STO&nbsp;&nbsp;&nbsp;&nbsp; HOPWD2<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                HOP&nbsp;&nbsp;&nbsp;&nbsp; HOPSET2<br>
                HOPSET1&nbsp; HOPCON&nbsp; AVG1, XCOMP<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                HOPCON&nbsp; AVG1, YCOMP<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                HOPCON&nbsp; AVG1, ZCOMP<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                HOPCON&nbsp; AVG2, XCOMP<br>
                HOPSET2&nbsp; HOPCON&nbsp; AVG3, YCOMP<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                HOPCON&nbsp; AVG3, ZCOMP<br>
                EXITHOP&nbsp; ( exit hop con )<br>
                STRTLINK HOPCON&nbsp; SQRT, XCOMP<br>
                THISSEC1 HOPCON&nbsp; AVG4, AVG4<br>
                THISSEC2 HOPCON&nbsp; AVG5, AVG5<br>
                THISSEC3 HOPCON&nbsp; AVG6, AVG6<br>
                <br>
                # Compute a double-precision square root.<br>
                SQRT&nbsp;&nbsp;&nbsp;&nbsp; STO&nbsp;&nbsp;&nbsp;&nbsp;
                RETURN<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                CLA&nbsp;&nbsp;&nbsp;&nbsp; ZERO<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                STO&nbsp;&nbsp;&nbsp;&nbsp; NORMCNT<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                CLA&nbsp;&nbsp;&nbsp;&nbsp; ARG<br>
                NORMTEST AND&nbsp;&nbsp;&nbsp;&nbsp; HIGH3<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                TNZ&nbsp;&nbsp;&nbsp;&nbsp; NORMDUN<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                CLA&nbsp;&nbsp;&nbsp;&nbsp; NORMCNT<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                ADD&nbsp;&nbsp;&nbsp;&nbsp; ONE<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                STO&nbsp;&nbsp;&nbsp;&nbsp; NORMCNT<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                CLA&nbsp;&nbsp;&nbsp;&nbsp; ARG<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                SHF&nbsp;&nbsp;&nbsp;&nbsp; L2<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                STO&nbsp;&nbsp;&nbsp;&nbsp; ARG<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                TRA&nbsp;&nbsp;&nbsp;&nbsp; NORMTEST<br>
                HIGH3&nbsp;&nbsp;&nbsp; DEC&nbsp;&nbsp;&nbsp;&nbsp; -.75<br>
                1/2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                DEC&nbsp;&nbsp;&nbsp;&nbsp; .5<br>
                SLOPELO&nbsp; DEC&nbsp;&nbsp;&nbsp;&nbsp; .4162<br>
                BIASLO&nbsp;&nbsp; DEC&nbsp;&nbsp;&nbsp;&nbsp; .1487<br>
                SLOPEHI&nbsp; DEC&nbsp;&nbsp;&nbsp;&nbsp; .2942<br>
                BIASHI&nbsp;&nbsp; DEC&nbsp;&nbsp;&nbsp;&nbsp; .2046<br>
                NORMDUN&nbsp; AND&nbsp;&nbsp;&nbsp;&nbsp; 1/2<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                TNZ&nbsp;&nbsp;&nbsp;&nbsp; ARGHI<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                CLA&nbsp;&nbsp;&nbsp;&nbsp; ARG<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                MPY&nbsp;&nbsp;&nbsp;&nbsp; SLOPELO<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                SHF&nbsp;&nbsp;&nbsp;&nbsp; R1<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                STO&nbsp;&nbsp;&nbsp;&nbsp; ARG<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                CLA&nbsp;&nbsp;&nbsp;&nbsp; BIASLO<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                ADD&nbsp;&nbsp;&nbsp;&nbsp; PQ<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                TRA&nbsp;&nbsp;&nbsp;&nbsp; NEWTON<br>
                ARGHI&nbsp;&nbsp;&nbsp; CLA&nbsp;&nbsp;&nbsp;&nbsp; ARG<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                MPY&nbsp;&nbsp;&nbsp;&nbsp; SLOPEHI<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                SHF&nbsp;&nbsp;&nbsp;&nbsp; R1<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                STO&nbsp;&nbsp;&nbsp;&nbsp; ARG<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                CLA&nbsp;&nbsp;&nbsp;&nbsp; BIASHI<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                ADD&nbsp;&nbsp;&nbsp;&nbsp; PQ<br>
                NEWTON&nbsp;&nbsp; STO&nbsp;&nbsp;&nbsp;&nbsp; BUF<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                CLA&nbsp;&nbsp;&nbsp;&nbsp; ARG<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                DIV&nbsp;&nbsp;&nbsp;&nbsp; BUF<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                ADD&nbsp;&nbsp;&nbsp;&nbsp; ZERO<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                ADD&nbsp;&nbsp;&nbsp;&nbsp; ZERO<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                ADD&nbsp;&nbsp;&nbsp;&nbsp; ZERO<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                ADD&nbsp;&nbsp;&nbsp;&nbsp; ZERO<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                ADD&nbsp;&nbsp;&nbsp;&nbsp; ZERO<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                ADD&nbsp;&nbsp;&nbsp;&nbsp; ZERO<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                ADD&nbsp;&nbsp;&nbsp;&nbsp; ZERO<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                CLA&nbsp;&nbsp;&nbsp;&nbsp; PQ<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                SHF&nbsp;&nbsp;&nbsp;&nbsp; R1<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                ADD&nbsp;&nbsp;&nbsp;&nbsp; BUF<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                STO&nbsp;&nbsp;&nbsp;&nbsp; BUF<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                CLA&nbsp;&nbsp;&nbsp;&nbsp; ARG<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                DIV&nbsp;&nbsp;&nbsp;&nbsp; BUF<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                ADD&nbsp;&nbsp;&nbsp;&nbsp; ZERO<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                ADD&nbsp;&nbsp;&nbsp;&nbsp; ZERO<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                ADD&nbsp;&nbsp;&nbsp;&nbsp; ZERO<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                ADD&nbsp;&nbsp;&nbsp;&nbsp; ZERO<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                ADD&nbsp;&nbsp;&nbsp;&nbsp; ZERO<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                ADD&nbsp;&nbsp;&nbsp;&nbsp; ZERO<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                ADD&nbsp;&nbsp;&nbsp;&nbsp; ZERO<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                CLA&nbsp;&nbsp;&nbsp;&nbsp; BUF<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                SHF&nbsp;&nbsp;&nbsp;&nbsp; R1<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                ADD&nbsp;&nbsp;&nbsp;&nbsp; PQ<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                STO&nbsp;&nbsp;&nbsp;&nbsp; ARG<br>
                CLANORC&nbsp; CLA&nbsp;&nbsp;&nbsp;&nbsp; NORMCNT<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                TNZ&nbsp;&nbsp;&nbsp;&nbsp; POSTSQRT<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                CLA&nbsp;&nbsp;&nbsp;&nbsp; ARG<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                SHF&nbsp;&nbsp;&nbsp;&nbsp; R1<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                STO&nbsp;&nbsp;&nbsp;&nbsp; ARG<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                TRA&nbsp;&nbsp;&nbsp;&nbsp; CLANORC<br>
                <br>
                # Calling sequence for SQRT (or similar for any other
                unary subroutine).<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                CLA&nbsp;&nbsp;&nbsp;&nbsp; X<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                STO&nbsp;&nbsp;&nbsp;&nbsp; ARG<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                CLA&nbsp;&nbsp;&nbsp;&nbsp; REHOP<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                HOP&nbsp;&nbsp;&nbsp;&nbsp; SQRTLINK<br>
                RETURN&nbsp;&nbsp; CLA&nbsp;&nbsp;&nbsp;&nbsp; ARG<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>
                REHOP&nbsp;&nbsp;&nbsp; HOPCON&nbsp; RETURN<br>
                SQRTLINK HOPCON&nbsp; SQRT<br>
              </span></small></td>
        </tr>
      </tbody>
    </table>
    <br>
    <h2><a name="yaLVDC_the_LVDC_CPU_Emulation"
        id="yaLVDC_the_LVDC_CPU_Emulation"></a><small><big>yaLVDC, the
          LVDC CPU Emulation</big></small></h2>
    <div style="text-align: center;">
      <div style="text-align: left;"> The inclusion of this section is
        an act of pure optimism.&nbsp; We don't have a working LVDC CPU
        emulator as of yet.<br>
        <br>
        <div style="text-align: center;"> <img style="width: 770px;
            height: 236px;" alt="" src="Saturn-GuidanceEquations.jpg"
            width="770" height="236"><br>
        </div>
        <br>
        An important thing to understand, in terms of simulation, is
        that the LVDC was not fast enough to keep up with the real-time
        calculations needed to directly control the rocket.&nbsp; The
        results would have been too stair-steppy, too choppy.&nbsp; 25
        outputs per second isn't enough!&nbsp; What happened instead is
        that a separate unit — the LVD<i>A</i> — was needed to accept
        the digital outputs from the LVDC and turn them into
        smoothly-changing controls for the rocket. And when I say
        smoothly-changing, I mean both smoothly in <i>time</i> as well
        as in terms of electrical properties. Thus any decent simulation
        would require simulation of not only the LVDC but also of the
        LVDA, the latter of which is currently outside the scope of
        what's being provided here.<br>
        <br>
        An interesting aspect of the LVDC is that since it is
        essentially a "black box" that outputs real-time control signals
        in response to real-time inputs, it is possible to create a
        reasonably satisfactory behavioral simulation for it in the
        absence of the original software, if one simply knows the <a
          href="Documents/SaturnVLaunchVehicleGuidanceEquations.pdf">
          guidance equations</a> relating the outputs to the
        inputs.&nbsp; While creating behavior simulations is not an
        objective of the Virtual AGC project as far as the Apollo CPUs
        are concerned, there are people engaged in creating such
        simulations for the <span style="font-weight: bold;">Orbiter</span>
        NASSP project and elsewhere.<br>
      </div>
    </div>
    <h2><a name="yaLVDCASM_the_LVDC_Cross-Assembler"
        id="yaLVDCASM_the_LVDC_Cross-Assembler"></a>yaASM.py, the LVDC
      Cross-Assembler</h2>
    The original IBM 360 based LVDC assembler used during Project Apollo
    itself is no longer available 50+ years later ... or at least, not
    available to <i>us</i>.&nbsp; So I've written an LVDC assembler
    completely from scratch.&nbsp; It's capable of accepting the
    original LVDC source code without any modifications, and producing
    an assembly listing similar to the original one, as well as a rope
    image that's 100% identical to the octal rope listing from the
    original printouts.&nbsp; <br>
    <br>
    In saying this, I suppose it's important to reiterate that while we
    have decent contemporaneous documentation of the LVDC instruction
    set, we have no contemporaneous documentation whatsoever of the
    format of LVDC assembly language, and specifically of the pseudo-ops
    or operand syntax of the language.&nbsp; In other words, while the
    new assembler works with the LVDC language documentation as
    described on this web page, this web page's documentation is based
    entirely on what I've personally inferred from reading the specific
    LVDC program printout available to me.&nbsp; Thus a listing of a
    different version of the original LVDC software, were one to become
    available, could easily have features which I've never seen before
    and which therefore are not yet accounted for in the new assembler.<br>
    <br>
    With that warning out of the way, <a
      href="https://github.com/virtualagc/virtualagc/tree/master/yaASM.py">the






















      modern LVDC assembler is called yaASM.py and is available in the
      Virtual AGC software repository</a>.&nbsp; Both the files yaASM.py
    and expression.py found there are necessary for running the
    assembler.&nbsp; As the naming implies, the assembler is written in
    the Python language — specifically Python 3, and it will not work
    with Python 2.&nbsp; Python programs such as this assembler are
    ready to run, as-is, and require no preparation or setup other than
    installation of Python itself.<br>
    <br>
    (Note:&nbsp; The yaASM.py program should not be confused with the
    yaASM program, which also appears in the repository.&nbsp; yaASM is
    an assembler program for Gemini OBC assembly language.&nbsp; The
    naming of these two programs is similar due to the fact that the
    LVDC and OBC are such similar computers.&nbsp; The original
    intention was that yaASM would be able to handle both OBC and LVDC
    assembly languages.&nbsp; However, yaASM was written in advance of
    any <i>true</i> samples of LVDC source code becoming
    available.&nbsp; When true LVDC samples became available much later,
    the inadequacy of yaASM with respect to the language features that
    it would need to handle became apparent, and the idea of using yaASM
    for the LVDC was abandoned.)<br>
    <br>
    Usage of the LVDC assembler is quite simple:<br>
    <blockquote><tt>yaASM.py [<i>OCTALS</i>.tsv] &lt;<i>INPUT</i>.lvdc
        &gt;<i>OUTPUT</i>.lst</tt><br>
    </blockquote>
    The assembler simply takes an input file of LVDC source code (<i>INPUT</i>.lvdc),






















    and produces as output a human-readable assembly listing (<i>OUTPUT</i>.lst).&nbsp;






















    Additionally, it produces a file containing an octal listing of the
    assembled code, which is always called yaASM.tsv.&nbsp; This file is
    produced whether or not there were fatal errors in the assembly
    process, so don't take the existence of the yaASM.tsv file as an
    indication that assembly succeeded.&nbsp; yaASM.tsv is what would be
    used to create an octal rope, if you had an LVDC, or which would be
    used as input to a software-based emulator for the LVDC CPU.&nbsp;
    The format of the file will be discussed in a moment.<br>
    <br>
    There is also an optional input file (<i>OCTALS</i>.tsv) for the
    assembly process.&nbsp; <i>OCTALS</i>.tsv, if available, is an
    octal listing of an LVDC rope in the same format as the output
    yaASM.tsv file.&nbsp; If present, the assembler performs a
    comparison during the assembly process of the contents of the input
    file <i>OCTALS</i>.tsv against that of the eventual output file
    yaASM.tsv, and provides messages indicating mismatches between the
    two.&nbsp; This can be helpful in debugging LVDC source code or in
    debugging the assembler itself.&nbsp; Of course, it's also possible
    to simply compare the two files directly with tools such as <b>diff</b>,
    but it's significantly more convenient to allow yaASM.py to do the
    comparison instead.&nbsp; For one thing, <i>OCTALS</i>.tsv can
    contain user-supplied comments; these would show up as differences
    from yaASM.tsv when using diff, but not when using yaASM.py.&nbsp;
    More importantly, when mismatches are found, messages generated by
    yaASM.py appear along with the lines of assembly-language code that
    generate the associated data.&nbsp; With tools similar to diff,
    matching the differences to the associated LVDC source code is a
    much more inconvenient process.<br>
    <br>
    As for the format of <i>OCTALS</i>.tsv or yaASM.tsv, the naming is
    intended to indicate that the files are tab-delimited ASCII files,
    which is largely true.<br>
    <ul>
      <li>Comments can be added by using the "#" character in column
        1.&nbsp; They are ignored during comparisons.<br>
      </li>
      <li>Empty lines are also ignored, and can be added for
        beatification purposes.</li>
      <li>Lines with 17 tab-delimited fields contain octal data for up
        to 8 memory words.&nbsp; Exactly 17 fields are always present,
        even if some of the memory locations are unused.<br>
      </li>
      <ul>
        <li>Field 1 is a 3-digit 0-padded octal number in the range
          000-377 (octal) that gives the starting memory offset of the
          line.&nbsp; Thus the number is always divisible by 8.</li>
        <li>The remaining 16 fields are pairs of 2 fields each:</li>
        <ul>
          <li>The first field contains one of the following:</li>
          <ul>
            <li>A 9-digit octal number (actual format " %09o% ") for a
              data word.&nbsp; Notice that the 9-digit number is
              bracketed by a space character on both the right and left,
              so the field is actually 11 characters wide.&nbsp; It can
              also be a string of 11 spaces
              ("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ") if
              the memory location is not used.<br>
            </li>
            <li>A pair of 5-digit octal numbers (actual format "%5o
              %5o") for two assembled instructions.&nbsp; The left-hand
              number is the assembled instruction for syllable 1 and the
              right-hand number is the instruction for syllable 0.&nbsp;
              Either the left-hand or right-hand number can also be 5
              spaces ("&nbsp;&nbsp;&nbsp;&nbsp; ") if not used.</li>
          </ul>
          <li>The second field contains just the character "D" for a
            memory word that is used, or just a space " " for a word
            that is not used. <br>
          </li>
        </ul>
      </ul>
      <li>Lines with 3 or more fields whose first field is the word
        "SECTOR" mark the beginning of a memory sector ... i.e., the
        next location will be 000.</li>
      <ul>
        <li>Field 1, as already mentioned, is the word "SECTOR".</li>
        <li>Field 2 is the number of the memory module, and is in the
          range 0-7.</li>
        <li>Field 3 is the number of the memory sector within the
          module.&nbsp; It is a 0-padded 2-digit octal number in the
          range 00-17 (octal).</li>
        <li>Fields 4+ are ignored.&nbsp; However, field 4 is often an
          encoded description of the proof-reading processes that have
          been undertaken to insure the correctness of the sector's
          data.</li>
      </ul>
    </ul>
    <p>Completely-empty memory sectors do not need to appear in the file
      at all.&nbsp; However, if any portion of a memory sector is used,
      the sector appears fully in the file.&nbsp; I.e., all of the lines
      with location fields 000, 010, ..., 370 will appear, even if most
      of their fields are blank.<br>
    </p>
    <div style="text-align: center;">
      <div style="text-align: left;">
        <h2><a name="Plea_for_Data" id="Plea_for_Data"></a>Plea for Data</h2>
        As you will have noted if you've read this far, there are some
        pretty serious gaps in the publicly-accessible data about the
        LVDC and its software.&nbsp; If you know where to find any more
        information, please tell me about it.&nbsp; Examples of some of
        the things that would be interesting to have include:<br>
        <ul>
          <li>Source code, source code, source code.&nbsp; Any computer
            source code—or for that matter, binary code—that ran on the
            LVDC would be useful:</li>
          <ul>
            <li>Flight software.</li>
            <li>Preflight software.</li>
            <li>Test &amp; checkout software.</li>
            <li>Even sample code.</li>
          </ul>
          <li>Manuals explaning the syntax of LVDC assembly-language.</li>
          <li>Source code for the software run by the test &amp;
            checkout computers, as opposed to the LVDC itself.</li>
          <li>Any documents missing from the <a href="links.html#LVDC">Document












































































              Library</a>.</li>
          <li>Developers' notes.</li>
        </ul>
        <h2><a name="Homage" id="Homage"></a>Homage<br>
        </h2>
        Well, we haven't made much progress on the homage
        front.&nbsp;&nbsp; I have a handful of names, though too few yet
        to really form any picture as to who did what.&nbsp; Hopefully
        be able to flesh this out somewhat as time progresses and to
        provide that info here.&nbsp; A lot of the information on this
        page that doesn't come directly from the surviving documentation
        is largely due to conversations with Barry Silverman, who has
        made a significant effort to find and talk to original LVDC
        developers.<br>
      </div>
    </div>
    <br>
    <hr style="width: 100%; height: 2px;">
    <center> <br>
      <span style="color: rgb(84, 89, 93); font-family: sans-serif;
        font-size: 11.05px; font-style: normal; font-variant: normal;
        font-weight: normal; letter-spacing: normal; line-height:
        16.575px; orphans: auto; text-align: center; text-indent: 0px;
        text-transform: none; white-space: normal; widows: 1;
        word-spacing: 0px; -webkit-text-stroke-width: 0px; display:
        inline !important; float: none; background-color: rgb(255, 255,
        255);"> This page is available under the <a
          href="https://creativecommons.org/publicdomain/zero/1.0/">Creative
Commons












































































          No Rights Reserved License</a></span><br>
      <i><font size="-1">Last modified by <a
            href="mailto:info@sandroid.org">Ronald Burkey</a> on
          2020-04-16.<br>
          <br>
          <a href="http://www.ibiblio.org"><img style="border: 0px solid
              ; width: 300px; height: 100px;" alt="Virtual AGC is hosted
              by ibiblio.org" src="hosted.png" width="300" height="100"></a><br>
        </font></i> </center>
    <br>
  </body>
</html>
